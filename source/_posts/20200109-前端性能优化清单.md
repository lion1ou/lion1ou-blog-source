---
title: 前端性能优化清单
toc: true
comments: true
date: 2020-01-09 14:58:32
categories:
tags:
photos:
---

<!--more-->

## HTML

1. 压缩 HTML 代码，将注释和空格都从生产环境去除

> 为了减少html文件大小

使用 webpack 插件 或 [HTML minifier | Minify Code](http://minifycode.com/html-minifier/)

2. **在 js 之前引用 css 文件，确保在使用 js 代码之前加载 css**

```html
<!-- 不推荐 -->
<script src="jquery.js"></script>
<script src="foo.js"></script>
<link rel="stylesheet" href="foo.css"/>

<!-- 推荐 -->
<link rel="stylesheet" href="foo.css"/>
<script src="jquery.js"></script>
<script src="foo.js"></script>
```

3. **尽量避免使用 iframe 标签**

4. **DNS 预取**

> 一次 DNS 查询时间大概在60-120ms之间或者更长，提前解析网页中可能的网络连接域名

```html
 <link rel="dns-prefetch" href="http://example.com/">
```


## CSS

1. **压缩所有 CSS 文件，减少 CSS 文件资源大小**

2. CSS 文件合并（对于 HTTP/2 效果不大）

3. CSS文件需要非阻塞引入，以防止DOM花费更多时间才能渲染完成。

```html
<link rel="preload" href="global.min.css" as="style" onload="this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="global.min.css"></noscript>
```

4. **关键CSS：将页面渲染时必备的CSS通过`<style></style>`的方式内联到页面中（尽可能压缩后引用）。**

> 内联关键CSS有助于加速网页的呈现，减少对服务器的请求数量。

使用在线工具或使用Addy Osmani开发的插件生成关键CSS。

5. 嵌入或内联CSS： 避免在中使用嵌入或内联CSS

> 因为将内容与设计分开是一种很好的做法。它还可以提高代码的可维护性并使站点可访问性更强。对于性能来说，它只是减少了HTML页面的文件大小和加载时间

6. 分析样式表的复杂性：分析样式表有助于发现有问题的、冗余和重复的CSS选择器。

7. 删除未使用的CSS选择器。

## 字体

1. 在你的网站或者应用使用WOFF2格式字体。

> 根据Google的说法，WOFF 2.0 Web字体压缩格式平均比WOFF 1.0高30％的增益。一个较好的做法是使用WOFF 2.0作为主要字体，WOFF 1.0和TTF格式字体作为备选。

2. 使用preconnect可以更快地加载字体

> 当你浏览网站时，设备需要获取网站所在的位置以及需要连接的服务器。浏览器必须连接DNS服务器并等待查找完成后再获取资源（字体，CSS文件...），prefetche和preconnect允许浏览器在空闲时进行上面的操作，在真实请求时就不需要再花时间去做一系列动作。这带来了性能的提升，因为当浏览器使用字体信息解析css文件并且从服务器请求字体文件时，它已经预先解析了DNS信息并且在其连接池中准备好与服务器的开放连接。

```html
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
```

效果： https://www.cdnplanet.com/blog/faster-google-webfonts-preconnect/

3. Webfont大小： Webfont尺寸不超过300kb（包括所有变体）

## 图片

1. **图片优化、压缩**
2. **图片格式转换，使用合适的图片格式**

> 比如 webp，有时候 PNG8比 PNG16好，有时候不一定

3. 使用矢量图像 VS 栅格/位图：可以的话，推荐使用矢量图像而不是位图图像。
4. 图像尺寸：如果已知最终渲染图像大小，请在上设置宽度和高度属性。

> 如果设置了高度和宽度，则在加载页面时会保留图像所需的空间。如果没有这些属性，浏览器就不知道图像的大小，也无法为其保留适当的空间，导致页面布局在加载期间发生变化

5. 避免使用Base64图像：你可以将微小图像转换为base64，但实际上并不是最佳实践。

> 编码后文件体积增大，仅适用于小体积图片编码，增加了编码和解码的工作量

6. 懒加载：图像懒加载（始终提供noscript作为后备方案）。

> 它能改善当前页面的响应时间，避免加载一些用户可能不需要或不必要的图像。

7. 响应式图像：确保提供接近设备显示尺寸的图像。

> 小型设备不需要比视口大的图像。建议在不同尺寸上使用一个图像的多个版本。为不同的设备设置不同大小的图像。 使用srcset和picture为每个图像提供多种变体（variants）。

## JS

1. **JS 压缩： 所有JavaScript文件都要被压缩，生产环境中删除注释、空格和空行（在HTTP/2仍然有效果）。**
2. 不内嵌JavaScript: (仅对网站有效) 避免在body中间嵌入多个JavaScript代码，将JavaScript代码重新集中到外部文件中，放在或页面末尾（之前）。
> 将JavaScript嵌入代码直接放在中可能会降低页面速度，因为它在构建DOM时会加载。最好的选择是使用async 或 defer的外部文件来避免阻塞DOM渲染。另一种选择是在`<script></script>`中放置一些脚本。大多数时候是需要在DOM进入主处理之前加载的分析代码或小脚本。

3. **非阻塞JavaScript: 使用defer属性或使用async来异步加载JavaScript文件。**

> JavaScript阻止HTML文档的正常解析，因此当解析器到达`<script>`标记时（特别是在内），它会停止解析并且执行脚本。如果您的脚本位于页面顶部，则强烈建议添加async和defer，但如果在标记之前加载，没有太大影响。但是，使用这些属性来避免性能问题是一种很好的做法。添加async（如果脚本不依赖于其他脚本）或defer（如果脚本依赖或依赖于异步脚本）作为script脚本标记的属性。 如果有小脚本，可以在异步脚本上方使用内联脚本。

```html
<!-- Defer Attribute -->
<script defer src="foo.js"></script>

<!-- Async Attribute -->
<script async src="foo.js"></script>
```

4. 优化和更新的JS库：项目中使用的所有JavaScript库都是有用到的 (推荐使用原生JS的简单功能)并更新到最新版本

> 大多数情况下，新版本都带有优化和安全性修复，所以应该使用最优化的代码来优化项目。确保不存在过时插件。如果项目使用NPM管理依赖包，[npm-check](https://www.npmjs.com/package/npm-check)是一个非常有用的库来升级/更新你的库。

5. JavaScript 分析：检查JavaScript文件（以及CSS）中的性能问题。

6. 使用 Service Workers

7. 使用 tree shaking 技术减少 js 大小: 通过构建工具分析 JavaScript 代码并移除生产环境中用不到的 js 模块或方法

8. 使用 code splitting 分包加载 js: 通过分包加载，减少首次加载所需时间

## Server

1. 网站使用HTTPS

2. 页面大小 < 1500 KB(理想 < 500 KB): (理想情况 < 500 KB) 尽可能减少页面和资源的大小。

3. 页面加载时间 < 3秒：尽可能减少页面加载时间，以便快速将内容传递给用户。

4. TTFB < 1.3 seconds：尽可能减少浏览器在接收数据之前等待的时间。

5. Cookie 大小: 如果您使用cookie，请确保每个cookie不超过4096字节，并且一个域名下不超过20个cookie。

6. 最小化HTTP请求：始终确保所请求的每个文件对网站或应用程序至关重要，尽可能减少http请求。

7. 使用CDN提供静态文件：使用CDN可以更快地在全球范围内获取到你的静态文件。

8. 提供来自相同协议的文件：避免网站使用HTTPS同时使用HTTP来提供相同源地址的文件。

9. 提供可访问的文件：避免请求无法访问的文件（404）。

10. 正确设置HTTP缓存标头：合理设置HTTP缓存标头来减少http请求次数。

11. 启用GZIP压缩 使用压缩方法（如Gzip或Brotli）来减小JavaScript文件的大小。使用较小尺寸的文件，用户可以更快地下载资源，从而提高性能。

12. 分域存放资源： 由于浏览器同一域名并行下载数有限，利用多域名主机存放静态资源，增加并行下载数，缩短资源加载时间

13. 减少页面重定向