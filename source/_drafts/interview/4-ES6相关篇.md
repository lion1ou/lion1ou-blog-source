# ES6语法

## 严格模式

[阮一峰博客](http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html)

`use strict`是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为

* 不使用var声明变量严格模式中将不通过
* 静态绑定，不支持以下形式的动态绑定
    * 任何使用'eval'的操作都会被禁止
    * with被禁用
* 增强安全措施
    * 禁止this关键字指向全局对象
    * 禁止在函数内部遍历调用栈，caller/callee 被禁用
* 禁止删除对象(delete)
* 对禁止扩展的对象添加新属性会报错
* 对一个对象的只读属性进行赋值将报错
* 对象有重名的属性将报错，函数有重名的参数也报错
* 禁止八进制表示法
* arguments对象的限制
    * 不允许对arguments赋值
    * arguments 不再追踪参数的变化
    * 禁止使用arguments.callee
* 函数必须声明在顶层，不允许在非函数代码块中声明函数
* 保留字新增(implements, interface, let, package, private, protected, public, static, yield)



## ES6的理解

* 新增模板字符串（为JavaScript提供了简单的字符串插值功能）
* for-of（用来遍历数据—例如数组中的值。）
* arguments对象可被不定参数和默认参数完美代替。
* 增加了块级作用域。let命令实际上就增加了块级作用域。
* 还有就是引入module模块的概念
* 设置函数参数默认值
* spread/rest 操作符，通过...的形式，遍历数组
* 对象和数组解构赋值，避免中间变量

[ECMAScript 6 入门详情：http://es6.ruanyifeng.com/](http://es6.ruanyifeng.com/)

## 箭头函数

* 箭头函数中的 this 和调用时的上下文无关
* 箭头函数中的 this 是简单的沿作用域链向上查找
* 剪头函数相对于普通函数，还少了如this,argument,super(ES6)...这些自动绑定的局部变量

函数中 this 总是绑定总是指向对象自身。具体可以看看下面几个例子：

```js
function Person() {
  this.age = 0;
  setInterval(function growUp() {
    // 在非严格模式下，growUp() 函数的 this 指向 window 对象
    this.age++;
  }, 1000);
}
var person = new Person();
```

我们经常需要使用一个变量来保存 this，然后在 growUp 函数中引用：

```js
function Person() {
  var self = this;
  self.age = 0;
  setInterval(function growUp() {
    self.age++;
  }, 1000);
}
```

## let和const

* let声明的变量具有块级作用域
* let 和 const 声明只在最靠近的一个块中（花括号内）有效
* 当使用常量 const 声明时，请使用大写变量，如：CAPITAL_CASING，const 在声明时必须被赋值
* 在for循环中不会出现输出结果为最后的数值（还可以使用闭包和立即执行函数解决）

```js
var a = []
for (var i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i)
    }
}
a[5]()
```

```js
var a = []
for (let i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i)
    }
}
a[5]()
```

```js
function showNum (i) {
    return function () {
        console.log(i)
    }
}
var a = []
for (var i = 0; i < 10; i++) {
    a[i] = showNum(i)
}
a[5]()
```

```js
var a = []
for (var i = 0; i < 10; i++) {
    a[i] = (function (j) {
        return function () {
            console.log(j)
        }
    })(i)
}
a[5]()
```

## Promise的使用
```js
(function() {
    var params = 1;
    function newPromise(a) {
        return new Promise(function(resolve, reject) {
            if (a === 1) {
                reject('qqqq');
            } else {
                resolve("hdhdhdh");
            }
        })
    }
    newPromise(params).then(function(value) {
        console.log(value);
    }).catch(function(val) {
        console.log("aaaaa", val);
    });
})();
//   all  （所有改变结果才改变）
var promises = [2,3,4,5,6].map(function(id){
    return getJson(`/post/getInfo/${id}`)
})
Promise.all(promises).then(function(res){
    // ...
}).catch(function(){
    // ...
})
//   race (只要一个改变，结果就改变)
var promises = [2,3,4,5,6].map(function(id){
    return getJson(`/post/getInfo/${id}`)
})
Promise.race(promises).then(function(res){
    // ...
}).catch(function(){
    // ...
})
//   try (不管是不是异步执行都可以使用，如果是同步的话，就直接同步执行)
```

## async/await

1. async 函数返回一个Promise对象

```js
let res = async () {
    return 1; // 等同于 return await 1; 或 return Promise.resolve(1)
}
res().then(v => console.log(v))
```

>await关键字必须在async函数中使用，但是async函数里不一定有await

2. await 会阻塞当前任务，直到执行完毕

```js
let res = await getRes()
let test = await getTest()
```

>只有getRes完成后，getTest才会执行。如下方法可以并发执行

```js
// 方法一
let [res, test] = await Promise.all([getRes(), getTest()])

// 方法二
let resFn = getRes()
let testFn = getTest()
let res = await resFn
let test = await testFn
```

3. async返回reject的方法，当抛出异常等同于reject

```js
let res = async() => {
    await Promise.reject(1); // return Promise.reject(1) 或 throw 1
}
res.catch((v) => {console.log(v)})
```

>Promise.reject和throw都可以通过try{}catch{}来阻止reject的触发

### 为什么async/await编写出来的代码更好

* async/await 代码简洁，符合语义
* 错误处理，可以直接使用try{}catch(){}同时处理同步和异步请求，Promise内部`JSON.parse()`错误无法捕获
* 条件判断分支，根据请求的返回结果判断是否继续或再请求其他接口，代码会陷入嵌套魔咒，很冗余杂乱
* 中间值的获取，比如要用promise1的结果去请求promise2，然后在用promise1和promise2的结果去请求promise3，这个过程使用Promise就很复杂
* 异常堆栈，在一段串行多个promise中，抛出异常，无法定位异常的环节
* 调试，不能在某个promise.then代码上设断点

详见：[6个Async/Await完胜Promise的原因](https://loveky.github.io/2017/04/09/translate-6-reasons-why-javascripts-async-await-blows-promises-away/)

## module模块

历史上js是没有module体系，无法将一个大程序拆分成一些小的程序。在es6之前，有commonJs，AMD两种

* CommonJS是如何书写的呢
```js
const animal = require('./content.js')

// content.js
module.exports = 'a cat'
```

* require.js是这样做的

```js
// content.js
define('content.js', function () {
    return 'A cat'
})

require(['./content.js'], function (animal) {
    console.log(animal) // a cat
})
```

* ES6的语法（在我用的vue中，就使用的是这个）

```js
import animal from './content'
// content.js
export default 'a cat'
```

* es6 import的其他用法

在vue中可以 `import animal from './content'`

animal这个值可以根据你的喜欢而改变，但是有一个问题就是如果一旦引入的是函数或者变量时，你就必须和content中的名字保持一致，可以参照

```js
import { say, type } from './content'
```

常用的还有一种写法

```js
import * as content from './content'
```

这种写法就是表示所有的输出值都在这个对象上

## Class

>问题：JS如何实现数据以及功能的封装。（即类是如何实现的）?

Class和传统的构造函数是一样的，Class可以看作只是一个语法糖。

```js
function Add (x, y) {
    this.x = x
    this.y = y
}
Add.prototype.toString = function () {
    return `${this.x}+${this.y}=${this.x+this.y}`
}
var p = new Add(3, 8)
console.log(p.toString())
```

```js
Class Add {
    constructor (x, y) {
        this.x = x
        this.y = y
    }

    toString () {
        return `${this.x}+${this.y}=${this.x+this.y}`
    }
}
var p = new Add(2, 8)
console.log(p.toString())
```

### constructor 方法

* constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。
* 一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。
* 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。

### new操作符具体干了什么呢

* 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型
* 属性和方法被加入到 this 引用的对象中
* 新创建的对象由 this 所引用，并且最后隐式的返回 this

### 谈谈This对象的理解

* this总是指向函数的直接调用者（而非间接调用者）
* 如果有new关键字，this指向new出来的那个对象
* 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window

## 待解决问题


* JS 怎么实现一个类。怎么实例化这个类

js实现一个类，有三种方法：

* 构造函数形式
```js
function Student(name, age) {
    this.name = name || '小l'
    this.age = age || 10
    this.hello = () => {
        console.log(`hello, 我是${this.name}, 今年${this.age}`, this)
    }
    this.hello1 = function () {
        console.log(`hello, 我是${this.name}, 今年${this.age}`, this)
    }
}
Student.prototype.hello2 = function () {
    console.log(`hello, 我是${this.name}, 今年${this.age}`, this)
}
Student.prototype.hello3 = () => {
    console.log(`hello, 我是${this.name}, 今年${this.age}`, this)
}
let student1 = new Student('小明', 17)
student1.hello()
student1.hello1()
student1.hello2()
student1.hello3()

class Student {
    constructor(name, age){
        this.name = name
        this.age = age
    }
    hello () {
        console.log(this.name + this.age)
    }
}

let student2 = new Student('小q', 11)
student2.hello()


const Student = {
    name: 'xiao',
    age: 12,
    hello: function () {
        console.log(this.name, this.age)
    }
}
let student3 = Object.create(Student)
student3.hello()
```
