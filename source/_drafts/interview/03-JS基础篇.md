---
title: JS基础篇
toc: true
comments: true
date: 2019-08-20 14:50:15
categories:
tags:
photos:
---

<!--more-->

## Ajax原理
Ajax的原理简单来说是在用户和服务器之间加了—个中间层(AJAX引擎)，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据Ajax的过程只涉及JavaScript、XMLHttpRequest和DOM。XMLHttpRequest是ajax的核心机制

```js
// 1. 创建连接
var xhr = null;
xhr = new XMLHttpRequest()
// 2. 连接服务器
xhr.open('get', url, true) //  第三个参数是：是否异步

// 3. 监听上传进度
xhr.upload.onloadstart = function (params) {
  console.log('onloadstart', params)
}
xhr.upload.onprogress = function (params) {
  console.log('onprogress', params)
}
xhr.upload.onload = function (params) {
  console.log('onload', params)
}

// 4. 发送请求
xhr.send(null);

// 5. 接受请求，每当 readyState 改变时，就会触发 onreadystatechange 事件。
xhr.onreadystatechange = function(){
    if(xhr.readyState == 4){
    // 0: 请求未初始化，1: 服务器连接已建立，2: 请求已接收，3: 请求处理中，4: 请求已完成，且响应已就绪
        if(xhr.status == 200){ // 当 readyState 等于 4 且状态为 200 时，表示响应已就绪：
            success(xhr.responseText);
        } else { // fail
            fail && fail(xhr.status);
        }
    }
}
```

## js操作DOM

```html
<div class="test"></div>
<div id="test2"></div>
```

```js
var el = document.createElement('input');            // 创建‘input’元素
el.type = 'radio';
var el2 = document.createElement('input');            // 创建‘input’元素
el2.type = 'text';
var node = document.createTextNode('Hello World');    // 创建文本节点

document.getElementsByClassName('test')[0].appendChild(el); // 在.test元素下添加子元素

var list = document.getElementById('test2') ;       // 在#test2第一个元素前添加DOM
list.insertBefore(el2,list.childNodes[0]);

var oldEl = document.getElementsByClassName('test')[0]; // 将新元素替换掉.test元素
var parentNode = oldEl.parentNode;   // 获取.test的父级元素
parentNode.replaceChild(el2, oldEl);

var oldEl = document.getElementsByClassName('test')[0];  // 删除.test元素
var parentNode = oldEl.parentNode;
parentNode.removeChild(oldEl);
```


### innerHTML与outerHTML的区别？jQuery的html()与innerHTML的区别？
* innerHTML 设置或获取位于对象起始和结束标签内的 HTML
* outerHTML 设置或获取对象及其内容的 HTML 形式
* innerText 设置或获取位于对象起始和结束标签内的文本
* outerText 设置(包括标签)或获取(不包括标签)对象的文本

在IE下tbody、tr这些的innerHTML都是只读的，不允许写入，而在其他浏览器下则没问题。而jquery的html()里是用了try，catch来检测，如果报错则在catch里重新调用this.empty().append(value)，是通过append来添加字符串的。

闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用域链

## 说说你对作用域链的理解
* 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的
* 简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期

## 闭包特性

* 函数内再嵌套函数
* 内部函数可以引用外层的参数和变量
* 参数和变量不会被垃圾回收机制回

## 说说你对闭包的理解

使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念

## 写一个闭包

```js
function f1(){
    var a=0;
    return function f2(){
        return a;
    }
}
console.log(f1()()); // 0
// 原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。
```

## 内存泄漏

哪些常见操作会造成内存泄漏？

[内存泄漏](http://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/)

内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。

* 意外的全局变量，如在函数内没有声明变量，直接使用。为了防止这些错误发生，添加'use strict'; 在您的JavaScript文件的开头。 这使得能够更严格地解析JavaScript以防止意外的全局变量
* 被遗忘的计时器或回调函数，如：`element.addEventListener('click', onClick);`没有在不需要的时候使用`element.removeEventListener('click', onClick);`去除
* 闭包使用不当，闭包会常驻内存
* 脱离DOM的引用，在某个对象中，声明引用DOM节点，后来又将DOM删除。此时之前的引用还会存在与内存中

```js
var elements = {
    button: document.getElementById('button'),
    image: document.getElementById('image'),
    text: document.getElementById('text')
};
function doStuff() {
    image.src = 'http://some.url/image';
    button.click();
    console.log(text.innerHTML);
    // 更多逻辑
}
function removeButton() {
    // 按钮是 body 的后代元素
    document.body.removeChild(document.getElementById('button'));
    // 此时，仍旧存在一个全局的 #button 的引用
    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。
}
```

## 节流和防抖

https://juejin.im/post/5a35ed25f265da431d3cc1b1

### 函数防抖(debounce)

>概念： 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

生活中的实例： 如果有人进电梯（触发事件），那电梯将在10秒钟后出发（执行事件监听器），这时如果又有人进电梯了（在10秒内再次触发该事件），我们又得等10秒再出发（重新计时）。

### 函数节流(throttle)

>概念： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。


![](http://cdn.chuyunt.com/Fr7vn_kV-Os_qap6GR2JJjmAfqsf)
![](http://cdn.chuyunt.com/Fng6_aoYryFwhWl1VjFc2jPHW0_B)


函数防抖：
```js
function debounce(fn, wait) {
  var timer = null;
  return function () {
      var context = this
      var args = arguments
      if (timer) {
          clearTimeout(timer);
          timer = null;
      }
      timer = setTimeout(function () {
          fn.apply(context, args)
      }, wait)
  }
}

var fn = function () {
  console.log('boom')
}

setInterval(debounce(fn,500),1000) // 第一次在1500ms后触发，之后每1000ms触发一次

setInterval(debounce(fn,2000),1000) // 不会触发一次（我把函数防抖看出技能读条，如果读条没完成就用技能，便会失败而且重新读条）
```
之所以返回一个函数，因为防抖本身更像是一个函数修饰，所以就做了一次函数柯里化。里面也用到了闭包，闭包的变量是timer。

函数节流
```js
function throttle(fn, gapTime) {
  let _lastTime = null;

  return function () {
    let _nowTime = + new Date()
    if (_nowTime - _lastTime > gapTime || !_lastTime) {
      fn();
      _lastTime = _nowTime
    }
  }
}

let fn = ()=>{
  console.log('boom')
}

setInterval(throttle(fn,1000),10)
```
如图是实现的一个简单的函数节流，结果是一秒打出一次boom

## 对象的常用操作函数

* 字符串常用操作函数：

>charAt, charCodeAt, fromCharCode, indexOf, search, match, substring, slice, substr, replace, split, toLowerCase, toUpperCase

* 查询匹配：indexOf, search, match
* 截取抽取：substring(截取开始和结束位置，参数不支持负数), slice(截取开始和结束位置，参数支持负数), substr(截取开始位置后的几个字符，参数支持负数)
* 替换：replace('需要替换的字符或正则'，'替换成的字符')
* 分割：split('', 3)，分割位置，返回数组的最大长度

详见：[JavaScript之字符串的常用操作函数](http://lion1ou.win/2018/04/23/)

* 数组常见操作函数

>concat, join, pop, shift, unshift, push, slice, splice, sort, reverse, toString()

详见：[JavaScript之数组的常用操作函数](http://lion1ou.win/2018/04/24/)

* pop 移除数组最后一位
* push 添加到数组最后一位
* shift 移除数组第一位
* unshift 添加数组第一位
* splice 删除第几位开始的几个数据，并替换为传入值
* slice 截取指定的开始位置到结束位置之间的数据

## javascript的本地对象，内置对象和宿主对象

本地对象是ECMA官方定义好的对象；内置对象也是本地对象，只包括Global对象和Math对象；宿主对象包括BOM和DOM对象。

* 本地对象

定义为独立于宿主环境的ECMAScript实现提供的对象。

本地对象包括如下内容：Object、Function、String、Array、Boolean、Number、Date、 RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError。

* 内置对象

由ECMAScript实现提供的，独立与宿主环境的所有对象，在ECMAScript程序开始执行时出现。这意味着开发者不必明确实例化内置对象，它已经被实例化了。ECMA只定义了两个内置对象，即Global和Math（它们也是本地对象，根据定义，所有内置对象都是本地对象）。

>Global对象是ECMAScript中最特别的对象，因为实际上它根本不存在，不信，在浏览器console中输入Global，报错。Global对象是预定义的对象，作为JavaScript全局函数和全局属性的占位符。

全局属性：Infinity，NaN，undefined，null

全局函数：isNaN()，parseFloat()，parseInt()，decodeURI()，decodeURIComponent()，encodeURI()，encodeURIComponent()，eval()（eval函数会将传入的字符串当做JavaScript代码进行执行）

* 宿主对象

所有非本地对象都是宿主对象（host Object），即由ECMAScript实现的宿主环境提供的对象。所有的BOM和DOM对象都是宿主对象。如浏览器自带的document，window 等

## js的对象复制，深复制和浅复制

* 因为对象是引用类型，存放在堆中，是通过指针指向另一个位置，并不像基本类型，直接存储在栈内存中。在复制对象时，只是将指针指向同一个地方。
* [深入JavaScript基础之深浅拷贝](https://juejin.im/post/5b5affaef265da0f86543bc9)

> 1. 数组深复制：concat/slice/es6 解构赋值
> 2. 递归赋值
> 3. JSON字符串转换，stringify/parse(含有函数、undefined、symbol会被忽略)


```js

function deepClone (source) {
 let resultObj = source.construction === 'Array' ? [] : {}
 for (let keys in source) {
    if(source.hasOwnProperty(keys)){
        if(source[keys] && typeof source[keys] === 'object'){
            resultObj[keys] = deepClone(source[keys])
        } else {
            resultObj[keys] = source[keys]
        }
    }
 }
 return resultObj
}

let obj1 = {
    name: 'ssssss',
    num: 111,
    callfun: function () {
        return 'qqqq'
    },
    ii: null,
    qq: undefined,
    oo: Symbol('a'),
    ll: {
        kk: '22',
        hh: '222',
        ii: null,
        qq: undefined,
        oo: Symbol('a'),
    }
}

let obj2 = deepClone(obj1)

```

## 事件

[面试整理之DOM事件阶段](https://www.cnblogs.com/LIUYANZUO/archive/2016/03/29/5332583.html)

## 事件绑定和普通事件有什么区别

事件绑定就是针对dom元素的事件，绑定在dom元素上。普通事件即为非针对dom元素的事件。

* 普通事件不能同时注册多个事件
* 普通事件只在冒泡被调用

```js
// 普通事件
var btn = document.getElementById('id1')
btn.onclick = function () {
    console.log(1)
}
btn.onclick = function () {
    console.log(2)
}
// 事件绑定
btn.addEventListener('click', function(){
    console.log(1)
}, false)
btn.addEventListener('click', function(){
    console.log(2)
}, false)
```

## IE和DOM事件流的区别(事件模型)

* 执行顺序不同，IE采用冒泡型事件，DOM使用先捕获后冒泡型事件，Netscape使用捕获型事件
* 事件侦听函数的区别（参数不同，事件是否”on”，第三个参数的不同，this指向问题）
* 如何取消浏览器事件的传递
* 如何阻止浏览器默认事件的执行

## 事件委托

```html
<ul id="parent-list">
  <li id="post-1">Item 1</li>
  <li id="post-2">Item 2</li>
  <li id="post-3">Item 3</li>
  <li id="post-4">Item 4</li>
  <li id="post-5">Item 5</li>
  <li id="post-6">Item 6</li>
</ul>
```

```js
document.getElementById('parent-list').addEventListener('click', function (e) {
    // currentTarget 被绑定事件的dom对象
    console.log(e.currentTarget)
    if(e.target && e.target.nodeName.toLowerCase === 'li'){
        console.log('我是点击的li')
    }
})
```

详见：[javaScript事件详解](http://lion1ou.win/2018/01/27)


## event loop (事件循环)

[详细介绍](https://zhuanlan.zhihu.com/p/33058983)
[详细介绍](https://segmentfault.com/a/1190000004322358)

Macrotasks和Microtasks 都属于上述的异步任务中的一种，他们分别有如下API：

macrotasks: setTimeout, setInterval, setImmediate, I/O, UI renderin； 

microtasks: process.nextTick, Promise, MutationObserver


> setTimeout、Promise、Async/Await 的区别

事件循环中分为宏任务队列和微任务队列。
* settimeout的回调函数会放到宏任务队列里，等到执行栈清空以后执行；
* promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；
* async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。

### 简述同步和异步的区别

![](https://ww1.sinaimg.cn/large/006tNbRwgy1fd44olhgt5j30i10a174m.jpg)

同步和异步的区别。同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性。改变顺序性其实也没有什么大不了的，只不过让程序变得稍微难理解了一些

### js延迟加载的方式有哪些？

* defer异步并行加载js文件，会按照页面上script标签的顺序执行
* async异步并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行
* 动态创建DOM方式,加载完毕后callBack（用得最多）
* 按需异步载入js

### 线程与进程的区别
* 一个程序至少有一个进程,一个进程至少有一个线程。
* 线程的划分尺度小于进程，使得多线程程序的并发性高。
* 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
* 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
* 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

## js的基本数据类型

原始类型：**Undefined**、**Null**、**Boolean**、**Number**、**String**、**Object** 和 **Symbols** (ES6 新提出的)

Symbols：符号类型是唯一的并且是不可修改的, 并且也可以用来作为Object的key的值(如下).

[symbols详细内容](http://es6.ruanyifeng.com/#docs/symbol)

> 问：为什么使用 void 0 来赋值给 值为undefined的变量

## js数据类型判断

1. typeof：返回一个表示数据类型的字符串，返回结果包括：**number**、**boolean**、**string**、**object**、**undefined**、**function**这6种数据类型，如果是判断一个基本的类型用typeof就是可以的。
2. instanceof：是用来判断 A 是否为 B 的实例，表达式为：`A instanceof B`，如果A是B的实例，则返回true，否则返回false，在这里需要特别注意的是：instanceof检测的是原型。
3. construction：任何一个对象都有constructor属性，指向创建这个对象的构造函数
4. Object.prototype.toString.call()：toString是Object原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString运行时this指向的对象类型, 返回的类型格式为[object,xxx],xxx是具体的数据类型，其中包括：String、Number、Boolean、Undefined、Null、Function、Date、Array、RegExp、Error、HTMLDocument... 基本上所有对象的类型都可以通过这个方法获取到。

```javascript
function isArray(arg) {
    if (typeof arg === 'object') {
        return Object.prototype.toString.call(arg) === '[object Array]';
    }
    return false;
}
```

## 例举

3种强制类型转换和2种隐式类型转换？ ”==”和“===”的不同? （网易电面）

* 强制（parseInt,parseFloat,Number(),Boolean(),String()）
* 隐式（== – + !）
* ==存在隐式转换数据格式，然后进行判断，===不转换直接判断

## null和undefined、not defined的区别

（网易电面、阿里电面）

* null是一个表示"空值"的对象，转为数值时为0；
* undefined :是一个表示"无"的原始值或者说表示"缺少值"。就是此处应该有一个值，但是还没有定义，当尝试读取时会返回 undefined，转为数值时为NaN。
* not defined: 是指既没有声明又没有赋值的情况，与undefined相同，typeof()=> 'undefined'

undefined：

1. 变量被声明了，但没有赋值时，就等于undefined。
2. 调用函数时，应该提供的参数没有提供，该参数等于undefined。
3. 对象没有赋值的属性，该属性的值为undefined。
4. 函数没有返回值时，默认返回undefined。

null：

1. 作为函数的参数，表示该函数的参数不是对象。
2. 作为对象原型链的终点。

## 进制转换

```js
var w = function (s) {
  document.write('<br>' + s)
};
//十进制转其他进制
var x=110;
w(x);
w(x.toString(8));
w(x.toString(32));
w(x.toString(16));

//其他进制转十进制
var x='110';
w(parseInt(x,2));
w(parseInt(x,8));
w(parseInt(x,16));

//其他转其他，先用parseInt转成十进制再用toString转到目标进制
w(String.fromCharCode(parseInt(141,8)))
w(parseInt('ff',16).toString(2));
```

## 小数的计算

[http://www.css88.com/archives/7340](http://www.css88.com/archives/7340)

* 方法一：使用tofixed()将`最后的计算结果`进行四舍五入，再返回一个数值的字符串表现形式，来提高结果精度
* 方法二：主要解决的方案是：将浮点数转换为字符串，分隔成整数部分和小数部分，小数部分再转换为整数，计算结束后，在转换为浮点型。(将小数全部转换成整数(扩大倍数)，计算完后再缩小相应倍数)


### XML和JSON的区别？

JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。
格式：采用键值对，例如：{'age':'12', 'name':'back'}

XML是一种扩展标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 XML使用DTD文档类型定义来组织数据，格式统一。XML是标准通用标记语言 (SGML) 的子集，适合 Web 传输。

* 数据体积方面，JSON相对于XML来讲，数据的体积小，传递的速度更快些。
* 数据交互方面，JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互
* 数据描述方面，JSON对数据的描述性比XML较差
* 传输速度方面，JSON的速度要远远快于XML


## JavaScript原型

[原型&原型链深度解读](https://juejin.im/post/5addd3db6fb9a07ab508839f)

> JavaScript原型（prototype），原型链? 有什么特cn点？

![](https://ws2.sinaimg.cn/large/006tKfTcgy1fr1fo3pujdj30xy0ew0tt.jpg)

![](https://ws4.sinaimg.cn/large/006tKfTcgy1fr1g5l5jzaj30eg0gaaam.jpg)

* 原型：在JavaScript中，原型也是一个对象，通过原型可以实现对象的属性继承，JavaScript的对象中都包含了一个`[[Prototype]]`内部属性，这个属性所对应的就是该对象的原型。"`[[Prototype]]`"作为对象的内部属性，是不能被直接访问的。Firefox和Chrome中提供了"`__proto__`"这个非标准（不是所有浏览器都支持）的访问器（ECMA引入了标准对象原型访问器"Object.getPrototype(object)"）

* 原型链：当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念

* 特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变

### 如何实现一个new

```js

function _new (fn, ...arg) {
    const obj = Object.create(fn.prototype)
    const ret = fn.apply(obj, arg)
    return ret instanceof Object ? ret : obj
}

```


## call、apply和bind

[详见博客 call、apply和bind的区别和作用](http://lion1ou.win/2018/01/26)


## 函数作用域，变量声明提升,函数声明提升
在JavaScript中函数内部的变量与函数外部的变量是存在于两个不同作用域下。

变量声明提升，只是把变量声明提升了，不会提升对应的赋值操作。

* `var s=10;` => `var s;` 在这之前s为undefined
* `var a=function(){}` => `var a` 所以在这之前调用a()会报错
* 但是`function b(){}`可以再其之前调用b()

在 JavaScript 中`变量和方法定义`会自动提升到执行之前。JavaScript 只有 function 级的定义域，而无其他很多编程语言中的块定义域，所以使得你在某一 function 内的某语句和循环体中定义了一个变量，此变量可作用于整个 function 内，而不仅仅是在此语句或循环体中，因为它们的声明被 JavaScript 自动提升了。

## this的指向

## 箭头函数和普通函数的区别

### js中arguments中callee和caller的区别

callee的意思是被调用者，caller的意思是调用者。

* callee：指向正在执行的函数。
* caller：指向调用当前函数的函数。

```js
var readBook = function(){
    console.log(arguments.callee);//这里返回的是readBook函数
    console.log(arguments.caller);//这里返回的应该是go函数 (以废除)
};
var go = function(){
    readBook();
};
go();
```

[详见：callee和caller用法和区别](https://www.w3cin.com/2016/04/25/callee%E5%92%8Ccaller%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/)



### eval是做什么的？
* 它的功能是把对应的字符串解析成JS代码并运行
* 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）
* 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')')


### 判断浏览器是否支持webp

```js
var isSupportWebp = !![].map && document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') === 0

// !![].map 用于判断是否是ie9+，否则toDataURL会报错
```


### [“1”, “2”, “3”].map(parseInt) 答案是多少？

[1, NaN, NaN]

因为 parseInt 需要两个参数 (val, radix)，其中radix 表示解析时用的基数(即将radix进制的数字转为10进制数字，radix 取值是在2-36，如果radix为0时，按十进制转换)。
而`array.map(function(currentValue,index,arr){}, thisValue)`，则传入parseInt的参数就是parseInt(currentValue, index)，所以得出来结果，parseInt('1',0),parseInt('2',1),parseInt('3',2)，对应的 radix 不合法导致解析失败。

### 如何减少项目中if else的使用次数，
* 使用一个对象包含多个键值对来对应的形式，a[b] = 'c'
* 使用swich case
* 使用二元一次表达式


### 谈谈你对commonjs、AMD、CMD的理解
* CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的
* AMD规范则是非同步加载模块，允许指定回调函数，AMD推荐的风格通过返回一个对象做为模块对象。
* CMD
* ES6 原生支持的import




