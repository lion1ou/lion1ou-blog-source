---
title: 前端框架
toc: true
comments: true
date: 2019-08-20 14:54:36
categories:
tags:
photos:
---

<!--more-->

### React 中组件的通信方式

- 父组件和子组件的通信：使用 props
- 子组件向父组件通信：使用 Props 的回调
- 跨级组件间的通信：使用 context 对象
- 非嵌套组件间通信：使用事件订阅

### React 生命周期

- constructor：构造函数，在创建组件的时候调用一次
- componentWillMount: 在组件挂载之前调用一次，在这个函数里调用 setState，本次的 render 函数可以看到更新后的 state，并且只渲染一次
- componentDidMount: 在组件挂载之后调用一次，这时候子组件都挂载完成了，可以是用 refs
- componentWillReceiveProps: props 是父组件传递给子组件的，父组件发生 render 的时候，子组件就会调用 componentWillReceiveProps（不管 props 有没有更新，也不管父子组件之间有没有数据交换）
- shouldComponentUpdate：组件挂载之后，每次调用 setState 后都会调用 shouldComponentUpdate 判断是否需要重新渲染组件。默认返回是 true，需要重新渲染，在比较复杂的应用里，有一些数据的改变是不影响界面展示的，所以可以在这里加判断，优化渲染效率。
- componentWillUpdate: shouleComponentUpdate 返回 true,或者调用 forceUpdate 之后，componentWillUpdate 就会被调用
- componentDidUpdate: 除了首次 render 之后调用的是 componentDidMount，其他 render 后都是调用 componentDidUpdate
- render: 是唯一一个 React 组件中必不可少的核心函数，不要在 render 中修改 state
- conponentWillUnmount：组件在被卸载的时候调用
- componentDidCatch() 错误边界

https://juejin.im/post/5c2cc0826fb9a049db733e79

### React 最新的生命周期是怎样的?

React 16 之后有三个生命周期被废弃(但并未删除)

- componentWillMount
- componentWillReceiveProps
- componentWillUpdate

官方计划在 17 版本完全删除这三个函数，只保留 UNSAVE\_前缀的三个函数，目的是为了向下兼容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们
目前 React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
挂载阶段:

- constructor: 构造函数，最先被执行,我们通常在构造函数里初始化 state 对象或者给自定义方法绑定 this
- getDerivedStateFromProps: static getDerivedStateFromProps(nextProps, prevState),这是个静态方法,当我们接收到新的属性想去修改我们 state，可以使用 getDerivedStateFromProps
- render: render 函数是纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑,可以返回原生的 DOM、React 组件、Fragment、Portals、字符串和数字、Boolean 和 null 等内容
- componentDidMount: 组件装载之后调用，此时我们可以获取到 DOM 节点并操作，比如对 canvas，svg 的操作，服务器请求，订阅都可以写在这个里面，但是记得在 componentWillUnmount 中取消订阅

更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
- shouldComponentUpdate: shouldComponentUpdate(nextProps, nextState),有两个参数 nextProps 和 nextState，表示新的属性和变化之后的 state，返回一个布尔值，true 表示会触发重新渲染，false 表示不会触发重新渲染，默认返回 true,我们通常利用此生命周期来优化 React 程序性能
- render: 更新阶段也会触发此生命周期
- getSnapshotBeforeUpdate: getSnapshotBeforeUpdate(prevProps, prevState),这个方法在 render 之后，componentDidUpdate 之前调用，有两个参数 prevProps 和 prevState，表示之前的属性和之前的 state，这个函数有一个返回值，会作为第三个参数传给 componentDidUpdate，如果你不想要返回值，可以返回 null，此生命周期必须与 componentDidUpdate 搭配使用
- componentDidUpdate: componentDidUpdate(prevProps, prevState, snapshot),该方法在 getSnapshotBeforeUpdate 方法之后被调用，有三个参数 prevProps，prevState，snapshot，表示之前的 props，之前的 state，和 snapshot。第三个参数是 getSnapshotBeforeUpdate 返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统一触发回调或更新状态。

卸载阶段:

- componentWillUnmount: 当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的 DOM 元素等垃圾清理工作

![16cbc24e71728047](http://cdn.chuyunt.com/uPic/16cbc24e71728047.png)

一个查看 react 生命周期的网站

### 更新方式

在 react 中，触发 render 的有 4 条路径。

1. 首次渲染 Initial Render
2. 调用 this.setState (并不是一次 setState 会触发一次 render，React 可能会合并操作，再一次性进行 render)
3. 父组件发生更新，(一般就是 props 发生改变，但就算 props 没有改变或者父子组件之前没有数据交换也会触发 render)
4. 调用 this.forceUpdate

![](https://ww1.sinaimg.cn/large/801b780agy1ftt6004vezj20jg0k3gos.jpg)

## Vue Vs React

### 监听数据变化的实现原理不同

- Vue 通过改写 Object.defindProperty 的 setter/getter 方法，来劫持监听数据的变化，然后在模板编译时收集依赖。以后只要修改 data 的任何一个属性，就会触发视图的重新渲染，而且是精确的修改对应的 vdom。不需要特别的优化就可以达到很好的性能
- 机制是每次 setState 的时候，调用 shouldComponentUpdate，判断 state 或 props 改变需不需要重新 render，如果返回 true 才会渲染。默认的实现是返回 true，PureComponent 的 shouldComponnentUpdate 浅层对比了两次 state，考虑到性能，需要写好 shouldComponentUpdate。React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的 VDom 重新渲染

### 数据流的不同

Vue:(在 Vue2.x 中去掉了第一种，也就是父子组件之间不能双向绑定了)

1. 父子组件之间，props 可以双向绑定
2. 组件与 DOM 之间可以通过 v-model 双向绑定

React: 不支持双向绑定，React 一直提倡的是单向数据流，他称之为 onChange/setState()模式。

> 一般都会用 Vuex 以及 Redux 等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了

### 组件通信的区别

- Vue

  - 父组件通过 props 向子组件传递数据或者回调
  - 子组件通过事件向父组件发送消息
  - 2.2 以后新增了 provide/inject 来实现，父组件向子组件注入数据，可以跨多个层级

- React
  - 父组件通过 props 可以向子组件传递数据或者回调
  - 可以通过 context 进行跨层级的通信，这其实和 provide/inject 起到的作用差不多。

### 模板渲染方式不同

在表层上，模板的语法不同

- React：是通过 JSX 渲染模板
- Vue：是通过 template，一个拓展的 HTML 语法进行渲染

在深层次，模板的原理不同

- React 在组件中，通过原生 JS 代码来实现模板中的常见语法，如插值，条件，循环
- Vue 在组件中，JS 代码和 HTML 相互分离，通过指令来实现的，如 v-if，v-for

## Vuex Vs Redux

表面上看：

- Vuex: 使用 dispatch 和 commit 提交更新，通过 mapState 或者直接通过 this.\$store 来读取数据。通过 action 来做异步请求操作
- Redux: 如果需要每个组件都显示，则使用 connect 把需要的 props 和 dispatch 连接起来，不能直接调用 redux

原理上看：

- Redux 使用的是不可变数据，而 Vuex 的数据是可变的。Redux 每次都是用新的 state 替换旧的 state，而 Vuex 是直接修改
- Redux 在检测数据变化的时候，是通过 diff 的方式比较差异的，而 Vuex 其实和 Vue 的原理一样，是通过 getter/setter 来比较的
- React 更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue 更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。

react 是整体的思路的就是函数式，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以做到，比如结合 redux-form，组件的横向拆分一般是通过高阶组件。而 vue 是数据可变的，双向绑定，声明式的写法，vue 组件的横向拆分很多情况下用 mixin。

## React Native

code push 有实现过吗？ 大概什么流程

code push 调用 react native 的打包命令，将当前环境的非 native 代码全量打包成一个 bundle 文件，然后上传到微软云服务器（Windows Azure）。 在 app 中启动页（或 splash 页）编写请求更新的代码（请求包含了本地版本，hashCode、appToken 等信息），微软服务端对比本地 js bundle 版本和微软服务器的版本，如果本地版本低，就下载新的 js bundle 下来后实现更新(code push 框架实现)。

## Proxy 相比于 defineProperty 的优势

Object.defineProperty() 的问题主要有三个：

- 不能监听数组的变化
- 必须遍历对象的每个属性
- 必须深层遍历嵌套的对象

Proxy 在 ES2015 规范中被正式加入，它有以下几个特点：

- 针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。这解决了上述 Object.defineProperty() 第二个问题

- 支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的。

除了上述两点之外，Proxy 还拥有以下优势：

- Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富

- Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法。

## 常规使用

### 使用 nextTick 和没使用有什么区别

Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。
$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM

详解： https://segmentfault.com/a/1190000012861862

### v-show 和 v-if

- v-show 指令是通过修改元素的 displayCSS 属性让其显示或者隐藏
- v-if 指令是直接销毁和重建 DOM 达到让元素显示和隐藏的效果

### vue 如何实现按需加载配合 webpack 设置?

webpack 中提供了 require.ensure()来实现按需加载。以前引入路由是通过 import 这样的方式引入，改为 const 定义的方式进行引入。
不进行页面按需加载引入方式：import home from '../../common/home.vue'
进行页面按需加载的引入方式：const home = r => require.ensure( [], () => r (require('../../common/home.vue')))

### `<keep-alive></keep-alive>`的作用是什么?

`<keep-alive></keep-alive>`包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。

[https://segmentfault.com/a/1190000010546663](https://segmentfault.com/a/1190000010546663)

大白话: 比如有一个列表和一个详情，那么用户就会经常执行打开详情=>返回列表=>打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用`<keep-alive></keep-alive>`进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染

[Vue keep-alive 深入理解及实践总结](https://juejin.im/post/5d5a534351882568916523b7)

### 请说下封装 vue 组件的过程？

答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。

然后，使用 Vue.extend 方法创建一个组件，然后使用 Vue.component 方法注册组件。子组件需要数据，可以在 props 中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用 emit 方法。

## Vue 的双向数据绑定原理

答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

```js
var Book = {};
Object.defineProperty(Book, "name", {
  set: function (value) {
    name = value;
    console.log("你取一个书名叫做" + value);
  },
  get: function () {
    return `《${name}》`;
  },
});
Book.name = "sss"; // 你取一个书名叫做sss
console.log(Book.name); // 《sss》
```

1. 要对所有对象进行监听，就需要通过递归方法，遍历所有属性值，并对其进行`Object.defindProperty()`处理
2. 植入订阅者，创建一个可以容纳订阅者的消息订阅器，

[详细内容：https://www.cnblogs.com/canfoo/p/6891868.html](https://www.cnblogs.com/canfoo/p/6891868.html)

### v-model

> v-model 是什么？怎么使用？ vue 中标签怎么绑定事件？

可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue 的 model 层的 data 属性

## vue 生命周期

答：总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。

创建前/后：

- 在 beforeCreated 阶段，vue 实例的挂载元素\$el 和数据对象 data 都为 undefined，还未初始化。
- 在 created 阶段，vue 实例的数据对象 data 有了，\$el 还没有。

载入前/后：

- 在 beforeMount 阶段，vue 实例的\$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。
- 在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。

更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。

销毁前/后：

- 在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在

> vue 生命周期的理解

vue 生命周期总共分为 8 个阶段: 创建前/后，载入前/后，更新前/后， 销毁前/后。

- beforeCreate （创建前）vue 实例的挂载元素\$el 和数据对象 data 都是 undefined, 还未初始化

- created (创建后) 完成了 data 数据初始化, el 还未初始化

- beforeMount (载入前) vue 实例的\$el 和 data 都初始化了, 相关的 render 函数首次被调用。实例已完成以下的配置：编译模板，把 data 里面的数据和模板生成 html。注意此时还没有挂载 html 到页面上。

- mounted (载入后) 在 el 被新创建的 vm.\$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的 html 内容替换 el 属性指向的 DOM 对象。完成模板中的 html 渲染到 html 页面中。此过程中进行 ajax 交互

- beforeUpdate (更新前) 在数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。

- updated （更新后） 在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。

- beforeDestroy (销毁前） 在实例销毁之前调用。实例仍然完全可用。

- destroyed (销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。

## Vue diff 算法

比较两棵 DOM 树的差异是 Virtual DOM 算法最核心的部分.简单的说就是新旧虚拟 dom 的比较，如果有差异就以新的为准，然后再插入的真实的 dom 中，重新渲染。
借网络一张图片说明:

比较只会在同层级进行, 不会跨层级比较。比较后会出现四种情况：

- 此节点是否被移除 -> 添加新的节点
- 属性是否被改变 -> 旧属性改为新属性
- 文本内容被改变 -> 旧内容改为新内容
- 节点要被整个替换 -> 结构完全不相同 移除整个替换

## vuex

答：vuex 可以理解为一种开发模式或框架。比如 PHP 有 thinkphp，java 有 spring 等。

- 通过状态（数据源）集中管理驱动组件的变化（好比 spring 的 IOC 容器对 bean 进行集中管理）。
- 应用级的状态集中放在 store 中；
- 改变状态的方式是提交 mutations，这是个同步的事物；
- 异步逻辑应该封装在 action 中。

### 谈谈 Vue 中的 MVVM 模式

MVVM 全称为 Model-View-ViewModel

把一个普通 Javascript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。(Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。
)
