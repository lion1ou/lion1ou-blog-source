# 网络协议

## 一次完整的HTTP事务

1. 浏览器输入URL
2. 解析DNS，先从浏览器的缓存，然后再到系统缓存，网络上的DNS服务器，获取对应的IP地址
3. 与服务器发起TCP的3次握手；
4. 建立TCP连接后发起HTTP请求
5. 服务器对应请求返回相应的html代码
6. 浏览器解析html代码，根据html代码请求其他相关资源（css、js、img等）
7. 浏览器渲染页面，显示给用户

### 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）

* https://zhuanlan.zhihu.com/p/34453198?group_id=957277540147056640

>注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；

详细版：

* 浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;
* 调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;
* 通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;
* 进行HTTP协议会话，客户端发送报头(请求报头);
* 进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;
* 进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;
* 处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;
* 浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;
* 文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;
* 页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。

简洁版：

* 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；
* 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
* 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；
* 载入解析到的资源文件，渲染页面，完成。

## HTTP状态码

* 1XX ： 信息状态码
    * 100 continue 继续，一般在发送POST请求时，已发送了header之后，服务端将返回此信息。
* 2XX ： 成功状态码
    * 200 OK 成功返回信息
    * 201 Created 请求成功并在服务器创建了新的资源
    * 202 Accepted 服务器已接受请求，但尚未处理
* 3XX ： 重定向
    * 301 Moved Permanently 请求的网页已经永久移动到新的位置
    * 302 Found 临时性重定向
    * 303 See Other 临时性重定向，且总使用Get请求新的URL
    * 304 Not Modified 自上次请求后，页面未修改过
* 4XX ： 客户端错误码
    * 400 Bad Request 服务器无法理解请求的格式，客户端不应该再次使用相同数据发起请求
    * 401 Unauthorized 请求未授权
    * 403 Forbidden 禁止访问
    * 404 Not Found 找不到如何网页
* 5XX ： 服务端错误码
    * 500 Internal Server Error 最常见的服务器端错误
    * 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）

## HTTP请求方法用途

* GET：GET可以说是最常见的了，它本质就是发送一个请求来取得服务器上的某一资源
* HEAD：HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息
* POST：向服务器提交数据，这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。
* PUT：这个方法比较少见。跟POST方法类似，向服务器提交数据，但是PUT指定了`资源在服务器上的位置`
* DETELE：删除服务器上的某个资源，基本上这个也很少见
* OPTIONS：极少使用。用于获取当前URL支持的方法，若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。
* TRACE：回显服务器收到的请求，主要用于测试或诊断。

### GET 和 POST 的区别

GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。GET在URL上添加参数，但是长度有限制。POST在header里面添加参数，数据长度没有限制。

两种者最大的区别是GET请求发送一个TCP数据包，POST发送两个TCP数据包。

GET在发送请求时，会把header和data一起发送出去，然后等待服务器返回数据
POST是先将header发送出去，等待服务器返回100（connect）,然后第二次再把data发送出去等待返回

>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

## 跨域相关

### 为什么要有同源限制？javascript的同源策略

* 同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议
* 举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。

1. 不同域名
2. 相同域名不同端口
3. 相同域名不同协议
4. 域名和指向该域名的IP地址
5. 子域名和主域名
6. 不同子域名

[跨域相关详细解释：https://zhuanlan.zhihu.com/p/25654664](https://zhuanlan.zhihu.com/p/25654664)
[http://www.ruanyifeng.com/blog/2016/04/cors.html](http://www.ruanyifeng.com/blog/2016/04/cors.html)

跨域方法主要有：CORS(ajax请求跨域)，JSONP(ajax请求跨域)，window.domain+iframe，window.name+iframe，HTML5的postMessage等方法

### 解释jsonp的原理，以及为什么不是真正的ajax

JSONP是一种非正式传输协议，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。

利用`<script>`标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。当需要通讯时，本站脚本创建一个`<script>`元素，地址指向第三方的API网址，形如：`<script src="http://www.example.net/api?callback=handle&param2=2"></script> `并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。第三方产生的响应为json数据的包装（故称之为jsonp，即json padding）

<!-- TODO 重新在整理一下 -->
## HTTP缓存机制 

HTTP缓存属于浏览器缓存（客户端缓存）：强制缓存，协商缓存

>两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。


### 强制缓存：

当缓存数据库里有所请求的数据时，浏览器会直接从缓存中获取数据。如果缓存数据库中没有所请求的数据时，才会从服务器获取数据。在根据缓存规则，存储到缓存数据库中。

![](https://ww2.sinaimg.cn/large/0069RVTdgy1ftvgggjyrrj31kw0m0tav.jpg)

对于强制缓存，服务器响应的header中会用两个字段来表明，Expires和Cache-Control

* Expires: 缓存过期时间，只要小于过期时间就用缓存（可能客户端和服务端时间有误差，少用）
* Cache-Control:
    * private：客户端可以缓存(默认)
    * public：客户端和代理服务器都可以缓存
    * max-age=t：缓存内容将在t秒后失效
    * no-cache：需要使用协商缓存来验证缓存数据
    * no-store：所有内容都不会缓存。


### 协商缓存

浏览器会先从缓存数据库中获取到一个缓存数据的标识（浏览器第一次请求时，服务器会将缓存标识一起响应给客户端），然后用标识请求服务器，验证数据是否有效，如果有效则会返回304，此时浏览器会直接获取本地缓存数据，如果失效，服务器会返回更新后的数据。

![](https://ww4.sinaimg.cn/large/0069RVTdgy1ftvggg9lzij31kw0jq41p.jpg)

* Last-Modified
    * Last-Modified: 服务器在响应请求时，会告诉浏览器资源的最后修改时间。
    * if-Modified-Since: 浏览器再次请求服务器的时候，请求头会包含此字段(会跟着在缓存中获得的最后修改时间)，和服务端的最后修改事件做对比。如果被修改了就返回新数据，code为200，如果没有修改就返回304.
    * if-Unmodified-Since: 从某个时间点算起, 是否文件没有被修改;如果没有修改则返回200，如果修改了则返回412(预处理错误)

* Etag(由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，很少使用Etag)
    * Etag: 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）
    * If-None-Match: 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。

### 缓存优点

    * 减少冗余数据传递，节省带宽流量
    * 减少服务器负担，提高网站性能
    * 加快客户端加载网页速度

### 不同刷新操作请求的执行过程

    * 地址栏写入Url，回车：发现有缓存文件，直接拿缓存
    * F5 刷新：发送一个带有if-Modify-Since的请求，判断文件是否过期
    * Ctrl+F5刷新：把客户端的缓存删了，再去请求完整的资源文件，强行更新


### HTTP2.0优势

  
* 二进制分帧层
  > 在应用层与传输层之间增加一个二进制分帧层，以此达到“在不改动HTTP的语义，HTTP 方法、状态码、URI及首部字段的情况下，突破HTTP1.1的性能限制，改进传输性能，实现低延迟和高吞吐量。

  > 在二进制分帧层上，HTTP2.0会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码，其中HTTP1.x的头部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。

* 压缩头部
  > HTTP/2.0规定了在客户端和服务器端会使用并且维护「首部表」来跟踪和存储之前发送的键值对，对于相同的头部，不必再通过请求发送，只需发送一次

  > 事实上,如果请求中不包含首部（例如对同一资源的轮询请求），那么首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。

  > 如果首部发生变化了，那么只需要发送变化了数据在Headers帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在 HTTP2.0的连接存续期内始终存在,由客户端和服务器共同渐进地更新。

* 多路复用
  >众所周知，在HTTP/1.1协议中，浏览器为了控制资源，还会对单个域名有6-8的个数限制，如下图，红色圈出来的请求就因域名链接数已超过限制，而被挂起等待了一段时间

  ![](http://cdn.chuyunt.com/picGo/download.png?imageslim)

  在 HTTP/2 中，有了二进制分帧之后，HTTP 2.0不再依赖TCP链接去实现多流并行了，在HTTP/2：

  * 同域名下所有通信都在单个连接上完成。
  * 单个连接可以承载任意数量的双向数据流。
  * 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。
  
  这一特性，性能会有极大的提升，因为：

  * 同个域名只需要占用一个TCP连接，消除了因多个TCP连接而带来的延时和内存消耗。
  * 单个连接上可以并行交错的请求和响应，之间互不干扰。

* 优先级请求

在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。
  
* 服务器推送

  * 服务器除了响应客户端的请求外，还可以向客户端额外推送资源。
  * 服务器推送的资源有自己独立的URL， 可以被浏览器缓存，可以达到多页面共享。
  * 资源推送遵守同源策略，服务器不可随便推送第三方资源给客户端。
  * 客户端可以拒绝推送过来的资源。
  
有了这一特性，我们可以做什么？

  * 应用可以通过额外的http头部，列出需要服务器推送哪些资源。
  * 服务器可以解析请求的html，推测出客户端接下来需要请求的资源，然后提前向客户端推送。

* 强制SSL
  > 虽然协议上没有声明一定要用SSL，但是浏览器强制要求使用SSL，即https

## 前端安全

### XSS（跨站脚本攻击）

是跨站脚本攻击（Cross-Site Scripting）的简称。XSS这类安全问题发生的本质原因在于，浏览器错误的将攻击者提供的用户输入数据当做JavaScript脚本给执行了。

> XSS有几种不同的分类办法，例如按照恶意输入的脚本是否在应用中存储，XSS被划分为“存储型XSS”和“反射型XSS”，如果按照是否和服务器有交互，又可以划分为“Server Side XSS”和“DOM based XSS”。

> 攻击者可以利用XSS漏洞来窃取包括用户身份信息在内的各种敏感信息、修改Web页面以欺骗用户，甚至控制受害者浏览器，或者和其他漏洞结合起来形成蠕虫攻击，等等。总之，关于XSS漏洞的利用，只有想不到没有做不到。

防御方法： 对数据进行严格的输出编码，使得攻击者提供的数据不再被浏览器认为是脚本而被误执行。例如`<script>`在进行HTML编码后变成了`&lt;script&gt;`，而这段数据就会被浏览器认为只是一段普通的字符串，而不会被当做脚本执行了。(现在的前端框架都已经默认提供了前端输出编码)

### CSRF（跨站点请求伪造）

首先来看个例子：

攻击者首先在自己的域构造一个页面：http://www.a.com/csrf.html，其内容为`<img src="http://blog.sohu.com/manage/entry.do?m=deleted&id=156714243" />`
使用了一个img标签，其地址指向了删除Iid为156714243的博客文章，然后攻击者诱使目标用户，也就是博客主人访问这个页面，用户进去看到一张无法显示的图片，这时自己的那篇博客文章已经被删除了
 

**原理：**在刚才访问http://www.a.com/csrf.html页面时，图片标签向服务器发送了一次get请求，这次请求导致了博客文章被删除
 这种删除博客文章的请求，是攻击者伪造的，所以这种攻击就叫做“跨站点请求伪造”

### 点击劫持（ClickJacking）

点击劫持是一种视觉上的欺骗手段。攻击者使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上。
 
防御点击劫持：X-Frame-Options

* X-Frame-Options HTTP响应头是用来给浏览器指示允许一个页面能否在`<frame>、<iframe>、<object>`中展现的标记
 
有三个可选的值

* DENY：浏览器会拒绝当前页面加载任何frame页面（即使是相同域名的页面也不允许）
* SAMEORIGIN：允许加载frame页面，但是frame页面的地址只能为同源域名下的页面
* ALLOW-FROM：可以加载指定来源的frame页面（可以定义frame页面的地址）

### iframe风险

前端页面使用第三方提供的外部页面组件，如果第三方被攻击或者域名过期被抢注了，iframe内容被替换，从而利用用户浏览器中的安全漏洞下载安装木马、恶意勒索软件等等

防御方法： 在HTML5中，iframe有了一个叫做sandbox的安全属性，通过它可以对iframe的行为进行各种限制，充分实现“最小权限“原则。[iframe中关于sandbox的介绍](http://www.w3school.com.cn/tags/att_iframe_sandbox.asp)

* 老生常谈的XSS
* 警惕iframe带来的风险
* 别被点击劫持了
* 错误的内容推断
* 防火防盗防猪队友：不安全的第三方依赖包
* 用了HTTPS也可能掉坑里
* 本地存储数据泄露
* 缺乏静态资源完整性校验