---
title: 面试前端
toc: true
comments: true
categories: 技术博客
tags: Default
date: 2019-11-05 12:00:21
photos:
description:
---

* https://juejin.im/post/5aae076d6fb9a028cc6100a9

## 基础题

### ES6

#### Promise

* promise 怎么使用

* async/await 实现原理

* promise 和 async/await 实现并发请求

* setTimeout(fn, 0) 和 promise谁先执行

```js
setTimeout(function() {
   console.log(1)
}, 0);

new Promise(function(resolve, reject) {
  console.log(2)
  for (var i = 0; i < 10000; i++) {
    if (i === 10) {
      console.log(10)
    }
    i == 9999 && resolve();
  }
  setTimeout(() => {
    console.log(9)
  }, 0)
  console.log(3)
}).then(function() {
   console.log(4)
})

console.log(5);
```


#### 函数

* 箭头函数和function有什么区别

* function的this指向

* bind、call和apply的使用和区别

#### Proxy

Proxy是ES6新增的一个构造函数，可以理解为JS语言的一个代理，用来改变JS默认的一些语言行为，包括拦截默认的get/set等底层方法，使得JS的使用自由度更高，可以最大限度的满足开发者的需求。比如通过拦截对象的get/set方法，可以轻松地定制自己想要的key或者value。下面的例子可以看到，随便定义一个myOwnObj的key,都可以变成自己想要的函数。

#### Symbol是什么，有什么作用？

答：  Symbol是ES6引入的第七种原始数据类型（说法不准确，应该是第七种数据类型，Object不是原始数据类型之一，已更正），所有Symbol()生成的值都是独一无二的，可以从根本上解决对象属性太多导致属性名冲突覆盖的问题。对象中Symbol()属性不能被for...in遍历，但是也不是私有属性。


### JS

#### Ajax

* ajax 原理是怎么实现的

通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据Ajax的过程只涉及JavaScript、XMLHttpRequest和DOM。XMLHttpRequest是ajax的核心机制

```js
// 1. 创建连接
var xhr = null;
xhr = new XMLHttpRequest()
// 2. 连接服务器
xhr.open('get', url, true) //  第三个参数是：是否异步

// 3. 监听上传进度
xhr.upload.onloadstart = function (params) {
  console.log('onloadstart', params)
}
xhr.upload.onprogress = function (params) {
  console.log('onprogress', params)
}
xhr.upload.onload = function (params) {
  console.log('onload', params)
}

// 4. 发送请求
xhr.send(null);

// 5. 接受请求，每当 readyState 改变时，就会触发 onreadystatechange 事件。
xhr.onreadystatechange = function(){
    if(xhr.readyState == 4){
    // 0: 请求未初始化，1: 服务器连接已建立，2: 请求已接收，3: 请求处理中，4: 请求已完成，且响应已就绪
        if(xhr.status == 200){ // 当 readyState 等于 4 且状态为 200 时，表示响应已就绪：
            success(xhr.responseText);
        } else { // fail
            fail && fail(xhr.status);
        }
    }
}
```

#### 节流与防抖

* 函数防抖(debounce)

>概念： 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

生活中的实例： 如果有人进电梯（触发事件），那电梯将在10秒钟后出发（执行事件监听器），这时如果又有人进电梯了（在10秒内再次触发该事件），我们又得等10秒再出发（重新计时）。

* 函数节流(throttle)

>概念： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。


![](http://7xvowi.s3-cn-east-1.qiniucs.com/Fr7vn_kV-Os_qap6GR2JJjmAfqsf)
![](http://7xvowi.s3-cn-east-1.qiniucs.com/Fng6_aoYryFwhWl1VjFc2jPHW0_B)

函数防抖：
```js
function debounce(fn, wait) {
  var timer = null;
  return function () {
      var context = this
      var args = arguments
      if (timer) {
          clearTimeout(timer);
          timer = null;
      }
      timer = setTimeout(function () {
          fn.apply(context, args)
      }, wait)
  }
}

var fn = function () {
  console.log('boom')
}

setInterval(debounce(fn,500),1000) // 第一次在1500ms后触发，之后每1000ms触发一次

setInterval(debounce(fn,2000),1000) // 不会触发一次（我把函数防抖看出技能读条，如果读条没完成就用技能，便会失败而且重新读条）
```
之所以返回一个函数，因为防抖本身更像是一个函数修饰，所以就做了一次函数柯里化。里面也用到了闭包，闭包的变量是timer。

函数节流
```js
function throttle(fn, gapTime) {
  let _lastTime = null;

  return function () {
    let _nowTime = + new Date()
    if (_nowTime - _lastTime > gapTime || !_lastTime) {
      fn();
      _lastTime = _nowTime
    }
  }
}

let fn = ()=>{
  console.log('boom')
}

setInterval(throttle(fn,1000),10)
```
如图是实现的一个简单的函数节流，结果是一秒打出一次boom


#### js的对象复制，深复制和浅复制

* 因为对象是引用类型，存放在堆中，是通过指针指向另一个位置，并不像基本类型，直接存储在栈内存中。在复制对象时，只是将指针指向同一个地方。
* [深入JavaScript基础之深浅拷贝](https://juejin.im/post/5b5affaef265da0f86543bc9)

> 1. 数组深复制：concat/slice/es6 解构赋值
> 2. 递归赋值
> 3. JSON字符串转换，stringify/parse(含有函数、undefined、symbol会被忽略)

#### call、apply和bind

[详见博客 call、apply和bind的区别和作用](http://lion1ou.win/2018/01/26)

### Vue

https://segmentfault.com/a/1190000016344599

#### Vue的生命周期

* beforeCreate（创建前） 在数据观测和初始化事件还未开始
* created（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来
* beforeMount（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。
* mounted（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。
* beforeUpdate（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。
* updated（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。
* beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。
* destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。

#### 项目中最困难的问题，怎么解决

#### Vue 双向绑定的原理

* 2.0+的原理（监听对象或数组的值）
* 3.0的原理

#### 虚拟dom diff算法

#### 你能实现一下双向绑定吗
```html
<body>
    <div id="app">
        <input type="text" id="txt">
        <p id="show-txt"></p>
    </div>
    <script>
        var obj = {}
        Object.defineProperty(obj, 'txt', {
            get: function () {
                return obj
            },
            set: function (newValue) {
                document.getElementById('txt').value = newValue
                document.getElementById('show-txt').innerHTML = newValue
            }
        })
        document.addEventListener('keyup', function (e) {
            obj.txt = e.target.value
        })
    </script>
</body>
```

### React 

#### 调用setState之后会发生什么

#### 优化React的性能 从哪里入手，shouldComponentUpdate 的作用是啥以及为何它这么重要？

#### 说下React的生命周期

实例化

getDefaultProps
getInitialState
componentWillMount
render
componentDidMount

存在期

componentWillReceiveProps
shouldComponentUpdate
componentWillUpdate
componentDidUpdate

销毁时

componentWillUnmount


### React Native 

### 其他

#### 输入URL到用户看到页面的过程

* https://zhuanlan.zhihu.com/p/34453198?group_id=957277540147056640

#### http

* http报文头部有哪些字段? 有什么意义 ?

* http和https的区别

* http2.0的优点

#### 浏览器缓存（整个过程，具体怎么判断）
浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：

* 先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；
* 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；
* 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；
* 区别是，强缓存不对发送请求到服务器，但协商缓存会。
* 当协商缓存也没命中时，服务器就会将资源发送回客户端。
* 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
* 当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；

* 强缓存
Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）
Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）

* 协商缓存
Last-Modified（值为资源最后更新时间，随服务器response返回）
If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）
ETag（表示资源内容的唯一标识，随服务器response返回）
If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）

#### webpack

* webpack 的 loader、plugin 分别什么用途，主要的区别是什么

loaders负责的是处理源文件的如css、jsx，一次处理一个文件。而plugins并不是直接操作单个文件，它直接对整个构建过程起作用下面列举了一些我们常用的plugins和他的用法

#### 移动端

* 移动端300ms延时的原因? 如何处理? 点击穿透怎么解决
* 移动端怎么做适配的，rem和em有什么区别
* 移动端滚动穿透，上层滚动下层也跟这个一起

#### 项目做过哪些性能优化？
* 减少 HTTP 请求数
* 减少 DNS 查询
* 使用 CDN
* 避免重定向
* 图片懒加载
* 减少 DOM 元素数量
* 减少 DOM 操作
* 使用外部 JavaScript 和 CSS
* 压缩 JavaScript 、 CSS 、字体、图片等
* 优化 CSS Sprite
* 使用 iconfont
* 字体裁剪
* 多域名分发划分内容到不同域名
* 尽量减少 iframe 使用
* 避免图片 src 为空
* 把样式表放在 中
* 把脚本放在页面底部
提取公用代码

### 深入题

* 对async、await的理解，内部原理  https://juejin.im/post/5d401ce4e51d4561d106cb63

* promise 的实现原理  https://zhuanlan.zhihu.com/p/58428287

* 从输入URL到页面加载的过程  https://zhuanlan.zhihu.com/p/34453198?group_id=957277540147056640

* react 虚拟DOM 是什么? 如何实现? 说一下diff算法   https://www.cnblogs.com/zhuzhenwei918/p/7271305.html

* JSbridge原理, js和native是如何通信的?

* webpack配置  具体怎么配置，如果写plugin