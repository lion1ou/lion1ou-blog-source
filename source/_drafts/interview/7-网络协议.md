# 网络协议

## 一次完整的HTTP事务

1. 浏览器输入URL
2. 解析DNS，先从浏览器的缓存，然后再到系统缓存，网络上的DNS服务器，获取对应的IP地址
3. 与服务器发起TCP的3次握手；
4. 建立TCP连接后发起HTTP请求
5. 服务器对应请求返回相应的html代码
6. 浏览器解析html代码，根据html代码请求其他相关资源（css、js、img等）
7. 浏览器渲染页面，显示给用户

### 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）

>注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；

详细版：

* 浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;
* 调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;
* 通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;
* 进行HTTP协议会话，客户端发送报头(请求报头);
* 进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;
* 进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;
* 处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;
* 浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;
* 文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;
* 页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。

简洁版：

* 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；
* 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
* 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；
* 载入解析到的资源文件，渲染页面，完成。

## HTTP状态码

* 1XX ： 信息状态码
    * 100 continue 继续，一般在发送POST请求时，已发送了header之后，服务端将返回此信息。
* 2XX ： 成功状态码
    * 200 OK 成功返回信息
    * 201 Created 请求成功并在服务器创建了新的资源
    * 202 Accepted 服务器已接受请求，但尚未处理
* 3XX ： 重定向
    * 301 Moved Permanently 请求的网页已经永久移动到新的位置
    * 302 Found 临时性重定向
    * 303 See Other 临时性重定向，且总使用Get请求新的URL
    * 304 Not Modified 自上次请求后，页面未修改过
* 4XX ： 客户端错误码
    * 400 Bad Request 服务器无法理解请求的格式，客户端不应该再次使用相同数据发起请求
    * 401 Unauthorized 请求未授权
    * 403 Forbidden 禁止访问
    * 404 Not Found 找不到如何网页
* 5XX ： 服务端错误码
    * 500 Internal Server Error 最常见的服务器端错误
    * 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）

## HTTP请求方法用途

* GET：GET可以说是最常见的了，它本质就是发送一个请求来取得服务器上的某一资源
* HEAD：HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息
* POST：向服务器提交数据，这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。
* PUT：这个方法比较少见。跟POST方法类似，向服务器提交数据，但是PUT指定了`资源在服务器上的位置`
* DETELE：删除服务器上的某个资源，基本上这个也很少见
* OPTIONS：极少使用。用于获取当前URL支持的方法，若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。
* TRACE：回显服务器收到的请求，主要用于测试或诊断。

### GET 和 POST 的区别

GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。GET在URL上添加参数，但是长度有限制。POST在header里面添加参数，数据长度没有限制。

两种者最大的区别是GET请求发送一个TCP数据包，POST发送两个TCP数据包。

GET在发送请求时，会把header和data一起发送出去，然后等待服务器返回数据
POST是先将header发送出去，等待服务器返回100（connect）,然后第二次再把data发送出去等待返回

>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

## 跨域相关

### 为什么要有同源限制？javascript的同源策略
* 同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议
* 举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。

1. 不同域名
2. 相同域名不同端口
3. 相同域名不同协议
4. 域名和指向该域名的IP地址
5. 子域名和主域名
6. 不同子域名

[跨域相关详细解释：https://zhuanlan.zhihu.com/p/25654664](https://zhuanlan.zhihu.com/p/25654664)
[http://www.ruanyifeng.com/blog/2016/04/cors.html](http://www.ruanyifeng.com/blog/2016/04/cors.html)

跨域方法主要有：CORS(ajax请求跨域)，JSONP(ajax请求跨域)，window.domain+iframe，window.name+iframe，HTML5的postMessage等方法

### 解释jsonp的原理，以及为什么不是真正的ajax
JSONP是一种非正式传输协议，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。

利用`<script>`标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。当需要通讯时，本站脚本创建一个`<script>`元素，地址指向第三方的API网址，形如：`<script src="http://www.example.net/api?callback=handle&param2=2"></script> `并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。第三方产生的响应为json数据的包装（故称之为jsonp，即json padding）

## webSocket如何兼容低浏览器？(阿里)

* Adobe Flash Socket 、
* ActiveX HTMLFile (IE) 、
* 基于 multipart 编码发送 XHR 、
* 基于长轮询的 XHR

## Axios实现原理

他以基于Promise的方法封装了浏览器的XMLHttpRequest和服务器端node http请求，使得我们可以使用es6土建的异步处理方法来请求

## HTTP缓存机制

HTTP缓存属于浏览器缓存（客户端缓存）：强制缓存，协商缓存

>两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。


### 强制缓存：

当缓存数据库里有所请求的数据时，浏览器会直接从缓存中获取数据。如果缓存数据库中没有所请求的数据时，才会从服务器获取数据。在根据缓存规则，存储到缓存数据库中。

![](https://ws2.sinaimg.in/large/0069RVTdgy1ftvgggjyrrj31kw0m0tav.jpg)

对于强制缓存，服务器响应的header中会用两个字段来表明，Expires和Cache-Control

* Expires: 缓存过期时间，只要小于过期时间就用缓存（可能客户端和服务端时间有误差，少用）
* Cache-Control:
    * private：客户端可以缓存(默认)
    * public：客户端和代理服务器都可以缓存
    * max-age=t：缓存内容将在t秒后失效
    * no-cache：需要使用协商缓存来验证缓存数据
    * no-store：所有内容都不会缓存。


### 协商缓存

浏览器会先从缓存数据库中获取到一个缓存数据的标识（浏览器第一次请求时，服务器会将缓存标识一起响应给客户端），然后用标识请求服务器，验证数据是否有效，如果有效则会返回304，此时浏览器会直接获取本地缓存数据，如果失效，服务器会返回更新后的数据。

![](https://ws4.sinaimg.in/large/0069RVTdgy1ftvggg9lzij31kw0jq41p.jpg)

* Last-Modified
    * Last-Modified: 服务器在响应请求时，会告诉浏览器资源的最后修改时间。
    * if-Modified-Since: 浏览器再次请求服务器的时候，请求头会包含此字段(会跟着在缓存中获得的最后修改时间)，和服务端的最后修改事件做对比。如果被修改了就返回新数据，code为200，如果没有修改就返回304.
    * if-Unmodified-Since: 从某个时间点算起, 是否文件没有被修改;如果没有修改则返回200，如果修改了则返回412(预处理错误)

* Etag(由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，很少使用Etag)
    * Etag: 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）
    * If-None-Match: 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。

### 缓存优点

    * 减少冗余数据传递，节省带宽流量
    * 减少服务器负担，提高网站性能
    * 加快客户端加载网页速度

### 不同刷新操作请求的执行过程

    * 地址栏写入Url，回车：发现有缓存文件，直接拿缓存
    * F5 刷新：发送一个带有if-Modify-Since的请求，判断文件是否过期
    * Ctrl+F5刷新：把客户端的缓存删了，再去请求完整的资源文件，强行更新


## HTTP2.0优势

* 多路复用
>众所周知，在HTTP/1.1协议中，浏览器
*

## 待解决问题

* http2.0,websocket,https，说一下你的理解以及你所了解的特性。
* 说下http协议,http协议中其中的每个协议的细节,http七层协议，最顶层是什么,http和https的区别
