# 设计模式


### 单例模式

单例模式在JavaScript的有多种用途，它用来划分命名空间。可以减少网页中全局变量的数量(在网页中使用全局变量有风险)；可以在多人开发时避免代码的冲突(使用合理的命名空间)等等。

在中小型项目或者功能中，单例模式可以用作命名空间把自己的代码组织在一个全局变量名下；在稍大或者复杂的功能中，单例模式可以用来把相关代码组织在一起以便日后好维护。　　

使用单例模式的方法就是用一个命名空间包含自己的所有代码的全局对象，示例：

```js
//使用对象字面量方法
var functionGroup = {
　　　　name:'Darren',
　　　　method1:function(){
　　　　　　//code
          console.log(this.name);
　　　　},
　　　　init:function(){
　　　　　　//code
　　　　}
　　}

functionGroup.method1();//'Darren'

var functionGroup  = function myGroup(){
　　　　this.name ='Darren';
　　　　this.getName =function(){
　　　　　　return this.name
　　　　}
　　　　this.method1 =function(){}
　　}

new functionGroup().getName();//'Darren'
//单例的最佳实践
var singletonTest=(function(){
    //只有在使用的时候才初始化
    function singleton(args){
        this.name=args.name||'singleton';
        this.type=args.type||'1';
    }

    var instance;

    var _static={
        name:"singletonTest",
        getInstance:function(args){
            if(!instance){
                instance= new singleton(args)
            }
            return instance;
        }   
    }
    return _static;
})();

console.log(singletonTest.getInstance({type:2}))
//singleton {name: "singleton", type: 2}
```


### 工厂模式
提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。

工厂就是把成员对象的创建工作转交给一个外部对象，好处在于消除对象之间的耦合(何为耦合？就是相互影响)。通过使用工厂方法而不是new关键字及具体类，可以把所有实例化的代码都集中在一个位置，有助于创建模块化的代码，这才是工厂模式的目的和优势。

举个例子：你有一个大的功能要做，其中有一部分是要考虑扩展性的，那么这部分代码就可以考虑抽象出来，当做一个全新的对象做处理。好处就是将来扩展的时候容易维护 - 只需要操作这个对象内部方法和属性，达到了动态实现的目的。

非常有名的一个示例 - XHR工厂：
```js
var XMLHttpFactory =function(){};　　　　　　//这是一个简单工厂模式
XMLHttpFactory.createXMLHttp =function(){
　 var XMLHttp = null;
　　if (window.XMLHttpRequest){
　　　　XMLHttp = new XMLHttpRequest()
　 }else if (window.ActiveXObject){
　　　　XMLHttp = new ActiveXObject("Microsoft.XMLHTTP")
　　}
return XMLHttp;
}
//XMLHttpFactory.createXMLHttp()这个方法根据当前环境的具体情况返回一个XHR对象。
var AjaxHander =function(){
　　var XMLHttp = XMLHttpFactory.createXMLHttp();
　　...
}
```

工厂模式又区分简单工厂模式和抽象工厂模式，上面介绍的是简单工厂模式，这种模式用的更多也更简单易用。抽象工厂模式的使用方法就是-先设计一个抽象类，这个类不能被实例化，只能用来派生子类，最后通过对子类的扩展实现工厂方法。 示例：

```js
var XMLHttpFactory =function(){};　     //这是一个抽象工厂模式
　　XMLHttpFactory.prototype = {
   　　//如果真的要调用这个方法会抛出一个错误，它不能被实例化，只能用来派生子类
   　　createFactory:function(){
      　　thrownew Error('This is an abstract class');
   　　}
　　}
　　//派生子类，文章开始处有基础介绍那有讲解继承的模式，不明白可以去参考原理
　　var XHRHandler =function(){
   　　XMLHttpFactory.call(this);
　　};
　　XHRHandler.prototype =new XMLHttpFactory();
　　XHRHandler.prototype.constructor = XHRHandler;
　　//重新定义createFactory 方法
　　XHRHandler.prototype.createFactory =function(){
   　　var XMLHttp =null;
   　　if (window.XMLHttpRequest){
      　　XMLHttp =new XMLHttpRequest()
   　　}elseif (window.ActiveXObject){
      　　XMLHttp =new ActiveXObject("Microsoft.XMLHTTP")
   　　}
   　　return XMLHttp;
　　}
```

### 桥接模式
在实现API的时候，桥接模式灰常有用。在所有模式中，这种模式最容易立即付诸实施。

桥接模式可以用来弱化它与使用它的类和对象之间的耦合，就是将抽象与其实现隔离开来，以便二者独立变化；这种模式对于JavaScript中常见的时间驱动的编程有很大益处，桥接模式最常见和实际的应用场合之一是时间监听器回调函数。

桥梁模式的要诀就是让接口“可桥梁”，实际上也就是可配置。把页面中一个个功能都想象成模块，接口可以使得模块之间的耦合降低。

桥梁模式目的就是让API更加健壮，提高组件的模块化程度，促成更简洁的实现，并提高抽象的灵活性。一个好的示例：
```
element.onclick =function(){　　//API可控制性提高了，使得这个API更加健壮
    new someFunction(element,param,callback);
}
```

### 装饰者（Decorator）模式
这个模式就是为对象增加功能(或方法)。

动态地给一个对象添加一些额外的职责。就扩展功能而言，它比生成子类方式更为灵活。

装饰者模式和组合模式有很多共同点，它们都与所包装的对象实现统一的接口并且会把任何方法条用传递给这些对象。可是组合模式用于把众多子对象组织为一个整体，而装饰者模式用于在不修改现有对象或从派生子类的前提下为其添加方法。

装饰者的运作过程是透明的，这就是说你可以用它包装其他对象，然后继续按之前使用那么对象的方法来使用，从下面的例子中就可以看出。还是从代码中理解吧：

### 构造函数模式
构造函数用于创建特定类型的对象——不仅声明了使用的对象，构造函数还可以接受参数以便第一次创建对象的时候设置对象的成员值。你可以自定义自己的构造函数，然后在里面声明自定义类型对象的属性或方法。

* 构造函数与原型

JavaScript里函数有个原型属性叫prototype，当调用构造函数创建对象的时候，所有该构造函数原型的属性在新创建对象上都可用。按照这样，多个Car对象实例可以共享同一个原型，我们再扩展一下上例的代码：
```js
function Car(model, year, miles) {
    this.model = model;
    this.year = year;
    this.miles = miles;
}

/*
注意：这里我们使用了Object.prototype.方法名，而不是Object.prototype
主要是用来避免重写定义原型prototype对象
*/
Car.prototype.output= function () {
    return this.model + "走了" + this.miles + "公里";
};

var tom = new Car("大叔", 2009, 20000);
var dudu = new Car("Dudu", 2010, 5000);

console.log(tom.output());
console.log(dudu.output());
```
这里，output()单实例可以在所有Car对象实例里共享使用。

另外：我们推荐构造函数以大写字母开头，以便区分普通的函数。


* 强制使用new

上述的例子展示了不使用new的问题，那么我们有没有办法让构造函数强制使用new关键字呢，答案是肯定的，上代码：
```js
function Car(model, year, miles) {
    if (!(this instanceof Car)) {
        return new Car(model, year, miles);
    }
    this.model = model;
    this.year = year;
    this.miles = miles;
    this.output = function () {
        return this.model + "走了" + this.miles + "公里";
    }
}

var tom = new Car("大叔", 2009, 20000);
var dudu = Car("Dudu", 2010, 5000);

console.log(typeof tom); // "object"
console.log(tom.output()); // "大叔走了20000公里"
console.log(typeof dudu); // "object"
console.log(dudu.output()); // "Dudu走了5000公里"
```
通过判断this的instanceof是不是Car来决定返回new Car还是继续执行代码，如果使用的是new关键字，则(this instanceof Car)为真，会继续执行下面的参数赋值，如果没有用new，(this instanceof Car)就为假，就会重新new一个实例返回。


* 代理模式

### 建造者模式
建造者模式可以将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。也就是说如果我们用了建造者模式，那么用户就需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。
```js
function getBeerById(id, callback) {
    // 使用ID来请求数据，然后返回数据.
    asyncRequest('GET', 'beer.uri?id=' + id, function (resp) {
        // callback调用 response
        callback(resp.responseText);
    });
}

var el = document.querySelector('#test');
el.addEventListener('click', getBeerByIdBridge, false);

function getBeerByIdBridge(e) {
    getBeerById(this.id, function (beer) {
        console.log('Requested Beer: ' + beer);
    });
}
```
根据建造者的定义，表相即是回调，也就是说获取数据以后如何显示和处理取决于回调函数，相应地回调函数在处理数据的时候不需要关注是如何获取数据的，同样的例子也可以在jquery的ajax方法里看到，有很多回调函数（比如success, error回调等），主要目的就是职责分离。

建造者模式主要用于“分步骤构建一个复杂的对象”，在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化，其优点是：建造者模式的“加工工艺”是暴露的，这样使得建造者模式更加灵活，并且建造者模式解耦了组装过程和创建具体部件，使得我们不用去关心每个部件是如何组装的。

* 命令模式
* 观察者模式
* 适配器模式
* 职责链模式
* 迭代器模式
