---
title: 面试基础题汇总
toc: true
comments: true
categories: 技术博客
tags: default
permalink: 20161110-01
date: 2016-11-10 11:22:36
photos:
---

最近在准备跳槽，为了换一个比现在薪资水平高，技术环境好的公司，所以我要好好准备面试。废话不多说，直接上正文，下面是我根据网上找到的材料整理的面试基础题。
<!--more-->

### 什么是盒子模型
在网页中，一个元素占有空间的大小主要由四个部分组成：margin（外边距）,padding（内边距）,border（边框线）,content（内容）。通过这四个部分的设定来，确定一个元素的位置。

### 行内元素有哪些？块级元素有哪些？

行内元素：a、b、i、span、img、input、select、label、button、textarea、iframe

块级元素：div、ul、li、h1-h6、p、form

### Cookie,Session
```js
//创建另一个函数来检查是否已设置 cookie
function getCookie(name) {
    if (document.cookie.length > 0) {
        c_start = document.cookie.indexOf(name + "=")
        if (c_start != -1) {
            c_start = c_start + name.length + 1
            c_end = document.cookie.indexOf(";", c_start)
            if (c_end == -1) c_end = document.cookie.length
            return unescape(document.cookie.substring(c_start, c_end))
        }
    }
    return ""
}
//创建一个可在 cookie 变量中存储访问者姓名的函数 
function setCookie(name, value, expiretimes) {
    var exdate = new Date(); //过期时间
    exdate.setTime(exdate.getTime() + expiretimes);
    document.cookie = name + "=" + escape(value) +
        ((expiretimes == null) ? "" : ";expires=" + exdate.toGMTString())
}

//如果 cookie 已设置，则显示欢迎词，否则显示提示框来要求用户输入名字。
function checkCookie() {
    username = getCookie('username')
    if (username != null && username != "") {
        alert('Welcome again ' + username + '!')
    } else {
        username = prompt('Please enter your name:', "")
        if (username != null && username != "") {
            setCookie('username', username, 10 * 1000) //10秒
        }
    }
}
```
### Promise的使用
```js
(function() {
    var add = 1;
    function newPromise(a) {
        return new Promise(function(resolve, reject) {
            if (a === 1) {
                reject('qqqq');
            } else {
                resolve("hdhdhdh");
            }
        })
    }
    newPromise(add).then(function(value) {
        console.log(value);
    }).catch(function(val) {
        console.log("aaaaa", val);
    });
})();
```
### 用原生js，实现Jquery的addclass/removeclass/hasclass功能
```js
function addclass(obj, cls) {
    var obj_class = obj.className;
    var a = (obj_class == '') ? '' : ' ';
    var add_class = obj_class + a + cls; //重新组合后的class
    obj.calssName = add_class; //替换原来的class
};
```

### 写一个数组去重
```js
var arr = ['a', 'b', 'c', '1', 0, 'c', 1, '', 1, 0];
///////////////////////////不兼容IE6-8
function unique2(arr) {
    var result = [];
    for (var i = 0; i < arr.length; i++) {
        if (result.indexOf(arr[i]) === -1) {
            result.push(arr[i]);
        }
    }
    return result; //["", 0, "1", 1, "a", "b", "c"]
}
console.log(unique2(arr));
///////////////////////////兼容所有浏览器
function indexOf(arr, item) {
    if ([].indexOf()) {
        var e = arr.indexOf(item);
        return e;
    } else {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] === item) {
                return i;
            }
        }
        return -1;
    }
}
function unique3(arr) {
    var result = [];
    for (var i = 0; i < arr.length; i++) {
        if (indexOf(result, arr[i]) === -1) {
            result.push(arr[i]);
        }
    }
    return result; //["", 0, "1", 1, "a", "b", "c"]
}
console.log(unique3(arr));

```
参考链接:[https://github.com/lifesinger/blog/issues/113](https://github.com/lifesinger/blog/issues/113)

### 一次完整的HTTP事务是怎样的一个过程？

基本流程：

1. 域名解析；
2. 发起TCP的3次握手；
3. 建立TCP连接后发起http请求；
4. 服务器端响应http请求，浏览器得到html代码；
5. 浏览器解析html代码，并请求html代码中的资源；
6. 浏览器对页面进行渲染呈现给用户。

### 常用正则表达式规则
### 浏览器的重绘（redraw）、重排(reflow)和重渲染有什么区别
### 简述同步和异步的区别

![](https://ww1.sinaimg.cn/large/006tNbRwgy1fd44olhgt5j30i10a174m.jpg)
同步和异步的区别。同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性。改变顺序性其实也没有什么大不了的，只不过让程序变得稍微难理解了一些 

### 抓包工具（Charles）
### 写一个闭包
```js
function f1(){
    var a=0;
    return function(){
        return a;
    }
}
console.log(f1()());
```

### 对前端工程师这个职位，你是怎么样理解的？

a. 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好
b. 参与项目，快速高质量完成实现效果图，精确到1px；
c. 与团队成员，UI设计，产品经理的沟通；
d. 做好的页面结构，页面重构和用户体验；
e. 处理hack，兼容、写出优美的代码格式；
f. 针对服务器的优化、拥抱最新前端技术。

#  ## xhtml和html有什么区别
HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言
最主要的不同：
XHTML 元素必须被正确地嵌套。
XHTML 元素必须被关闭。
标签名必须用小写字母。
XHTML 文档必须拥有根元素。

### 浏览器缓存的机制
### font-face是什么
### iconcss
### js原型链
### websocket是什么
### AppCan是什么框架来的
### js和css中缓存是怎样的
### 如何更新缓存的,缓存有哪些，他们之前有什么区别
### 给我讲讲几个设计模式是怎样的
### 说下http协议,http协议中其中的每个协议的细节,http七层协议，最顶层是什么,http和https的区别是什么,ssl底层协议是什么,https2.0和https1.0的区别。
### json和xml的区别
### 宽度优先搜索，深度优先搜索的原理
### 最小生成树是怎么弄的
### 写一个冒泡排序，然后怎么让他提前结束
### 对未来有什么规划
### 前后端分离的话，如何做SEO优化
### 变量声明提升,函数作用域,appendChild
### rem和em的区别
### 基础布局方式/常用定位的作用和区别
### css的一些常用的选择器以及选择器的权重
### css的浮动的应用场景和消除浮动的常用方法
### JavaScript继承和prototype的知识点
[面试整理之DOM事件阶段](http://www.cnblogs.com/LIUYANZUO/archive/2016/03/29/5332583.html)
[前端面试题整理——CSS篇](http://blog.csdn.net/haimianxiaojie/article/details/51115626)
[解决你的前端面试](https://segmentfault.com/a/1190000005127264)
[前端面试必会题目](http://www.jianshu.com/p/446d14d3c8ea)
[创业干货|腾讯架构师:程序员招聘与面试的正确姿势](http://www.yidianzixun.com/n/0El0Awpr?s=9&appid=yidian&ver=3.5.4&utk=0073fq70)
[数据类型转化](http://javascript.ruanyifeng.com/grammar/conversion.html)


### Javascript中callee和caller的作用？

caller是返回一个对函数的引用，该函数调用了当前函数；callee是返回正在被执行的function函数，也就是所指定的function对象的正文。

3.Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?
用于声明文档使用那种规范（html/Xhtml）一般为 严格 过度 基于框架的html文档
加入XMl声明可触发，解析方式更改为IE5.5 拥有IE5.5的bug

4.行内元素有哪些?块级元素有哪些?CSS的盒模型?
块级元素：div p h1 h2 h3 h4 form ul
行内元素: a b br i span input select
Css盒模型:内容，border ,margin，padding

5.CSS引入的方式有哪些? link和@import的区别是?
内联 内嵌 外链 导入
区别 ：同时加载
前者无兼容性，后者CSS2.1以下浏览器不支持
Link 支持使用javascript改变样式，后者不可

6.CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?
标签选择符 类选择符 id选择符
继承不如指定 Id>class>标签选择
后者优先级高

7.前端页面有哪三层构成，分别是什么?作用是什么?
结构层 Html 表示层 CSS 行为层 js

8.css的基本语句构成是?
选择器{属性1:值1;属性2:值2;……}--

9.你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么?
Ie(Ie内核) 火狐（Gecko） 谷歌（webkit） opear(Presto)

10.写出几种IE6 BUG的解决方法
1.双边距BUG float引起的 使用display
2.3像素问题 使用float引起的 使用dislpay:inline -3px
3.超链接hover 点击后失效 使用正确的书写顺序 link visited hover active
4.Ie z-index问题 给父级添加position:relative
5.Png 透明 使用js代码 改
6.Min-height 最小高度 ！Important 解决’
7.select 在ie6下遮盖 使用iframe嵌套
8.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px）

11.标签上title与alt属性的区别是什么?
Alt 当图片不显示是 用文字代表。
Title 为该属性提供信息

12.描述css reset的作用和用途。
Reset重置浏览器的css默认属性 浏览器的品种不同，样式不同，然后重置，让他们统一

13.解释css sprites，如何使用。
Css 精灵 把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量

14.浏览器标准模式和怪异模式之间的区别是什么?
盒子模型 渲染模式的不同
使用 window.top.document.compatMode 可显示为什么模式

15.你如何对网站的文件和资源进行优化?期待的解决方案包括：
文件合并
文件最小化/文件压缩
使用CDN托管
缓存的使用

16.什么是语义化的HTML?
直观的认识标签 对于搜索引擎的抓取有好处

17.清除浮动的几种方式，各自的优缺点
1.使用空标签清除浮动 clear:both（理论上能清楚任何标签，，，增加无意义的标签）
2.使用overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE）
3.是用afert伪元素清除浮动(用于非IE浏览器)

Javascript
1.javascript的typeof返回哪些数据类型
Object number function boolean underfind

2.例举3种强制类型转换和2种隐式类型转换?
强制（parseInt,parseFloat,number）
隐式（== – ===）

3.split() join() 的区别
前者是切割成数组的形式，后者是将数组转换成字符串

4.数组方法pop() push() unshift() shift()
Push()尾部添加 pop()尾部删除
Unshift()头部添加 shift()头部删除

5.事件绑定和普通事件有什么区别

6.IE和DOM事件流的区别
1.执行顺序不一样、
2.参数不一样
3.事件加不加on
4.this指向问题

7.IE和标准下有哪些兼容性的写法
Var ev = ev || window.event
document.documentElement.clientWidth || document.body.clientWidth
Var target = ev.srcElement||ev.target

8.ajax请求的时候get 和post方式的区别
一个在url后面 一个放在虚拟载体里面
有大小限制
安全问题
应用不同 一个是论坛等只需要请求的，一个是类似修改密码的

9.call和apply的区别
Object.call(this,obj1,obj2,obj3)
Object.apply(this,arguments)

10.ajax请求时，如何解释json数据
使用eval parse 鉴于安全性考虑 使用parse更靠谱
11.b继承a的方法

12.写一个获取非行间样式的函数

function getStyle(obj,attr,value)
{
if(!value)
{
if(obj.currentStyle)
{
return obj.currentStyle(attr)
}
else
{
obj.getComputedStyle(attr,false)
}
}
else
{
obj.style[attr]=value
}
}

13.事件委托是什么
让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！
http://www.webasily.com/?p=78 例子可见此链接

14.闭包是什么，有什么特性，对页面有什么影响
闭包就是能够读取其他函数内部变量的函数。
深入理解JavaScript的闭包特性 如何给循环中的对象添加事件 此链接可查看（问这个问题的不是一个公司）

15.如何阻止事件冒泡和默认事件
canceBubble return false

16.添加 删除 替换 插入到某个接点的方法
obj.appendChidl()
obj.innersetBefore
obj.replaceChild
obj.removeChild

17.解释jsonp的原理，以及为什么不是真正的ajax
动态创建script标签，回调函数
Ajax是页面无刷新请求数据操作

18.javascript的本地对象，内置对象和宿主对象
本地对象为array obj regexp等可以new实例化
内置对象为gload Math 等不可以实例化的
宿主为浏览器自带的document,window 等

19.document load 和document ready的区别
Document.onload 是在结构和样式加载完才执行js
Document.ready原生种没有这个方法，jquery中有 $().ready(function)

20.”==”和“===”的不同
前者会自动转换类型
后者不会

21.javascript的同源策略
一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合

22.编写一个数组去重的方法
```js
function oSort(arr)
{
var result ={};
var newArr=[];
for(var i=0;i<arr.length;i++)
{
if(!result[arr])
{
newArr.push(arr)
result[arr]=1
}
}
return newArr
}
```


2. 说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8 以下）
(Q1) 行内元素：会在水平方向排列，不能包含块级元素，设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效。
块级元素：各占据一行，垂直方向排列。从新行开始结束接着一个断行。
(Q2) 兼容性：display:inline-block;*display:inline;*zoom:1;
3. 清除浮动有哪些方式？比较好的方式是哪一种？
(Q1)
（1）父级div定义height。
（2）结尾处加空div标签clear:both。
（3）父级div定义伪类:after和zoom。
（4）父级div定义overflow:hidden。
（5）父级div定义overflow:auto。
（6）父级div也浮动，需要定义宽度。
（7）父级div定义display:table。
（8）结尾处加br标签clear:both。
(Q2) 比较好的是第3种方式，好多网站都这么用。
4. box-sizing常用的属性有哪些？分别有什么作用？
(Q1)box-sizing: content-box|border-box|inherit;
(Q2)content-box:宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。
border-box:元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。
5. Doctype作用？标准模式与兼容模式各有什么区别?
(Q1) <!DOCTYPE>告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。
(Q2) 标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。
6. HTML5 为什么只需要写 <!DOCTYPE HTML>？
HTML5不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。
而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。
7. 页面导入样式时，使用link和@import有什么区别？
（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;
（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;
（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。
8. 介绍一下你对浏览器内核的理解？
主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和js引擎。
渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。
浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。
JS引擎则：解析和执行javascript来实现网页的动态效果。
最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。
9. html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？
(Q1)
HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。
(1)绘画 canvas;
(2)用于媒介回放的 video 和 audio 元素;
(3)本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;
(4)sessionStorage 的数据在浏览器关闭后自动删除;
(5)语意化更好的内容元素，比如 article、footer、header、nav、section;
(6)表单控件，calendar、date、time、email、url、search;
(7)新的技术webworker, websocket, Geolocation;
(Q2)
IE8/IE7/IE6支持通过document.createElement方法产生的标签，
可以利用这一特性让这些浏览器支持HTML5新标签，
浏览器支持新标签后，还需要添加标签默认的样式。
当然也可以直接使用成熟的框架、比如html5shim，
<!--[if lt IE 9]>
<![endif]-->
10. 简述一下你对HTML语义化的理解？
用正确的标签做正确的事情。
html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;
搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于seo;
使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。
JavaScript
1. 介绍js的基本数据类型
Undefined、Null、Boolean、Number、String
2. js有哪些内置对象？
数据封装类对象：Object、Array、Boolean、Number 和 String
其他对象：Function、Arguments、Math、Date、RegExp、Error
3. this对象的理解
this总是指向函数的直接调用者（而非间接调用者）；
如果有new关键字，this指向new出来的那个对象；
在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window。
4. eval是做什么的？
它的功能是把对应的字符串解析成JS代码并运行；
应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。
由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')')。
5. DOM怎样添加、移除、移动、复制、创建和查找节点
// 创建新节点
createDocumentFragment //创建一个DOM片段
createElement //创建一个具体的元素
createTextNode //创建一个文本节点
// 添加、移除、替换、插入
appendChild
removeChild
replaceChild
insertBefore //在已有的子节点前插入一个新的子节点
// 查找
getElementsByTagName //通过标签名称
getElementsByName //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
getElementById //通过元素Id，唯一性
6. null和undefined的区别？
null是一个表示"无"的对象，转为数值时为0；undefined是一个表示"无"的原始值，转为数值时为NaN。
undefined：
（1）变量被声明了，但没有赋值时，就等于undefined。
（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。
（3）对象没有赋值的属性，该属性的值为undefined。
（4）函数没有返回值时，默认返回undefined。
null：
（1） 作为函数的参数，表示该函数的参数不是对象。
（2） 作为对象原型链的终点。
7. new操作符具体干了什么呢?
（1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
（2）属性和方法被加入到 this 引用的对象中。
（3）新创建的对象由 this 所引用，并且最后隐式的返回 this 。
8. JSON 的了解？
JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。
格式：采用键值对，例如：{'age':'12', 'name':'back'}
9. call 和 apply 的区别和作用？
apply函数有两个参数：第一个参数是上下文，第二个参数是参数组成的数组。如果上下文是null，则使用全局对象代替。
如：function.apply(this,[1,2,3]);
call的第一个参数是上下文，后续是实例传入的参数序列。
如：function.call(this,1,2,3);
10. 如何获取UA？
function whatBrowser {
document.Browser.Name.value=navigator.appName;
document.Browser.Version.value=navigator.appVersion;
document.Browser.Code.value=navigator.appCodeName;
document.Browser.Agent.value=navigator.userAgent;
}
其他
1. HTTP状态码知道哪些？
100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
200 OK 正常返回信息
201 Created 请求成功并且服务器创建了新的资源
202 Accepted 服务器已接受请求，但尚未处理
301 Moved Permanently 请求的网页已永久移动到新位置。
302 Found 临时性重定向。
303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。
304 Not Modified 自从上次请求后，请求的网页未修改过。
400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
401 Unauthorized 请求未授权。
403 Forbidden 禁止访问。
404 Not Found 找不到如何与 URI 相匹配的资源。
500 Internal Server Error 最常见的服务器端错误。
503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。
2. 你有哪些性能优化的方法？
（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。
（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存ajax请求结果，每次操作本地变量，不用请求，减少请求次数
（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。
（4） 当需要设置的样式很多时设置className而不是直接操作style。
（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。
（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。
（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。
3. 什么叫优雅降级和渐进增强？
优雅降级：web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。
由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。
渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。
4. 哪些常见操作会造成内存泄漏？
内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。
setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）。
5. 线程与进程的区别
一个程序至少有一个进程,一个进程至少有一个线程。
线程的划分尺度小于进程，使得多线程程序的并发性高。
另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

全局命名空间污染与 IIFE

总是将代码包裹成一个 IIFE(Immediately-Invoked Function Expression)，用以创建独立隔绝的定义域。这一举措可防止全局命名空间被污染。

IIFE 还可确保你的代码不会轻易被其它全局命名空间里的代码所修改（i.e. 第三方库，window 引用，被覆盖的未定义的关键字等等）。

不推荐

var x = 10, y = 100; // Declaring variables in the global scope is resulting in global scope pollution. All variables declared like this // will be stored in the window object. This is very unclean and needs to be avoided. console.log(window.x + ' ' + window.y);
推荐
/ We declare a IIFE and pass parameters into the function that we will use from the global space (function(log, w, undefined){ 'use strict'; var x = 10, y = 100; // Will output 'true true' log((w.x === undefined) + ' ' + (w.y === undefined)); }(window.console.log, window));
IIFE（立即执行的函数表达式）

无论何时，想要创建一个新的封闭的定义域，那就用 IIFE。它不仅避免了干扰，也使得内存在执行完后立即释放。

所有脚本文件建议都从 IIFE 开始。

立即执行的函数表达式的执行括号应该写在外包括号内。虽然写在内还是写在外都是有效的，但写在内使得整个表达式看起来更像一个整体，因此推荐这么做。

不推荐

(function{});推荐
(function{});so，用下列写法来格式化你的 IIFE 代码： (function{ 'use strict'; // Code goes here });如果你想引用全局变量或者是外层 IIFE 的变量，可以通过下列方式传参：
(function($, w, d){ 'use strict'; $(function { w.alert(d.querySelectorAll('div').length); }); }(jQuery, window, document));
严格模式

ECMAScript 5 严格模式可在整个脚本或独个方法内被激活。它对应不同的 javascript 语境会做更加严格的错误检查。严格模式也确保了 javascript 代码更加的健壮，运行的也更加快速。

严格模式会阻止使用在未来很可能被引入的预留关键字。

你应该在你的脚本中启用严格模式，最好是在独立的 IIFE 中应用它。避免在你的脚本第一行使用它而导致你的所有脚本都启动了严格模式，这有可能会引发一些第三方类库的问题。

不推荐

// Script starts here 'use strict'; (function{ // Your code starts here });推荐
(function{ 'use strict'; // Your code starts here });
变量声明

总是使用var来声明变量。如不指定 var，变量将被隐式地声明为全局变量，这将对变量难以控制。如果没有声明，变量处于什么定义域就变得不清（可以是在 Document 或 Window 中，也可以很容易地进入本地定义域）。所以，请总是使用 var 来声明变量。
采用严格模式带来的好处是，当你手误输入错误的变量名时，它可以通过报错信息来帮助你定位错误出处。

不推荐

x = 10; y = 100;推荐 var x = 10, y = 100;
理解 JavaScript 的定义域和定义域提升

在 JavaScript 中变量和方法定义会自动提升到执行之前。JavaScript 只有 function 级的定义域，而无其他很多编程语言中的块定义域，所以使得你在某一 function 内的某语句和循环体中定义了一个变量，此变量可作用于整个 function 内，而不仅仅是在此语句或循环体中，因为它们的声明被 JavaScript 自动提升了。

我们通过例子来看清楚这到底是怎么一回事：

原 function

(function(log){ 'use strict'; var a = 10; for(var i = 0; i < a; i++) { var b = i * i; log(b); } if(a === 10) { var f = function { log(a); }; f; } function x { log('Mr. X!'); } x; }(window.console.log));
被 JS 提升过后
(function(log){ 'use strict'; // All variables used in the closure will be hoisted to the top of the function var a, i, b, f; // All functions in the closure will be hoisted to the top function x { log('Mr. X!'); } a = 10; for(i = 0; i < a; i++) { b = i * i; log(b); } if(a === 10) { // Function assignments will only result in hoisted variables but the function body will not be hoisted // Only by using a real function declaration the whole function will be hoisted with its body f = function { log(a); }; f; } x; }(window.console.log));
根据以上提升过程，你是否可理解以下代码？

有效代码

(function(log){ 'use strict'; var a = 10; i = 5; x; for(var i; i < a; i++) { log(b); var b = i * i; } if(a === 10) { f = function { log(a); }; f; var f; } function x { log('Mr. X!'); } }(window.console.log));正如你所看到的这段令人充满困惑与误解的代码导致了出人意料的结果。只有良好的声明习惯，也就是下一章节我们要提到的声明规则，才能尽可能的避免这类错误风险。
提升声明

为避免上一章节所述的变量和方法定义被自动提升造成误解，把风险降到最低，我们应该手动地显示地去声明变量与方法。也就是说，所有的变量以及方法，应当定义在 function 内的首行。

只用一个var关键字声明，多个变量用逗号隔开。不推荐
(function(log){ 'use strict'; var a = 10; var b = 10; for(var i = 0; i < 10; i++) { var c = a * b * i; } function f { } var d = 100; var x = function { return d * d; }; log(x); }(window.console.log));推荐
(function(log){ 'use strict'; var a = 10, b = 10, i, c, d, x; function f { } for(i = 0; i < 10; i++) { c = a * b * i; } d = 100; x = function { return d * d; }; log(x); }(window.console.log));
把赋值尽量写在变量申明中。

不推荐

var a, b, c; a = 10; b = 10; c = 100;推荐
var a = 10, b = 10, c = 100;
总是使用带类型判断的比较判断

总是使用 === 精确的比较操作符，避免在判断的过程中，由 JavaScript 的强制类型转换所造成的困扰。

如果你使用 === 操作符，那比较的双方必须是同一类型为前提的条件下才会有效。

在只使用 == 的情况下，JavaScript 所带来的强制类型转换使得判断结果跟踪变得复杂，下面的例子可以看出这样的结果有多怪了：

(function(log){ 'use strict'; log('0' == 0); // true log('' == false); // true log('1' == true); // true log(null == undefined); // true var x = { valueOf: function { return 'X'; } }; log(x == 'X'); }(window.console.log));
明智地使用真假判断

当我们在一个 if 条件语句中使用变量或表达式时，会做真假判断。if(a == true)是不同于if(a)的。后者的判断比较特殊，我们称其为真假判断。这种判断会通过特殊的操作将其转换为 true 或 false，下列表达式统统返回 false：false''（空字符串）.
这种真假判断在我们只求结果而不关心过程的情况下，非常的有帮助。

以下示例展示了真假判断是如何工作的：

(function(log){ 'use strict'; function logTruthyFalsy(expr) { if(expr) { log('truthy'); } else { log('falsy'); } } logTruthyFalsy(true); // truthy logTruthyFalsy(1); // truthy logTruthyFalsy({}); // truthy logTruthyFalsy(); // truthy logTruthyFalsy('0'); // truthy logTruthyFalsy(false); // falsy logTruthyFalsy(0); // falsy logTruthyFalsy(undefined); // falsy logTruthyFalsy(null); // falsy logTruthyFalsy(NaN); // falsy logTruthyFalsy(''); // falsy }(window.console.log));
变量赋值时的逻辑操作

和&&也可被用来返回布尔值。如果操作对象为非布尔对象，那每个表达式将会被自左向右地做真假判断。基于此操作，最终总有一个表达式被返回回来。这在变量赋值时，是可以用来简化你的代码的。
不推荐

if(!x) { if(!y) { x = 1; } else { x = y; } }推荐
x = x || y || 1;这一小技巧经常用来给方法设定默认的参数。 (function(log){ 'use strict'; function multiply(a, b) { a = a || 1; b = b || 1; log('Result ' + a * b); } multiply; // Result 1 multiply(10); // Result 10 multiply(3, NaN); // Result 3 multiply(9, 5); // Result 45 }(window.console.log));
分号

总是使用分号，因为隐式的代码嵌套会引发难以察觉的问题。当然我们更要从根本上来杜绝这些问题[1]。以下几个示例展示了缺少分号的危害： // 1. MyClass.prototype.myMethod = function { return 42; } // No semicolon here. (function { // Some initialization code wrapped in a function to create a scope for locals. }); var x = { 'i': 1, 'j': 2 } // No semicolon here. // 2. Trying to do one thing on Internet Explorer and another on Firefox. // I know you'd never write code like this, but throw me a bone. [ffVersion, ieVersion][isIE]; var THINGS_TO_EAT = [apples, oysters, sprayOnCheese] // No semicolon here. // 3. conditional execution a la bash -1 == resultOfOperation || die;
So what happens?

JavaScript 错误 —— 首先返回 42 的那个 function 被第二个 function 当中参数传入调用，接着数字 42 也被“调用”而导致出错。
八成你会得到 ‘no such property in undefined’ 的错误提示，因为在真实环境中的调用是这个样子：x[ffVersion, ieVersion][isIE].
die 总是被调用。因为数组减 1 的结果是 NaN，它不等于任何东西（无论 resultOfOperation 是否返回NaN）。所以最终的结果是 die 执行完所获得值将赋给 THINGS_TO_EAT.
Why?

JavaScript 中语句要以分号结束，否则它将会继续执行下去，不管换不换行。以上的每一个示例中，函数声明或对象或数组，都变成了在一句语句体内。要知道闭合圆括号并不代表语句结束，JavaScript 不会终结语句，除非它的下一个 token 是一个中缀符[2]或者是圆括号操作符。
这真是让人大吃一惊，所以乖乖地给语句末加上分号吧。

澄清：分号与函数

分号需要用在表达式的结尾，而并非函数声明的结尾。区分它们最好的例子是：

var foo = function { return true; }; // semicolon here. function foo { return true; } // no semicolon here.
嵌套函数

嵌套函数是非常有用的，比如用在持续创建和隐藏辅助函数的任务中。你可以非常自由随意地使用它们。

语句块内的函数声明

切勿在语句块内声明函数，在 ECMAScript 5 的严格模式下，这是不合法的。函数声明应该在定义域的顶层。但在语句块内可将函数申明转化为函数表达式赋值给变量。

不推荐

if (x) { function foo {} }推荐
if (x) { var foo = function {}; }
异常

基本上你无法避免出现异常，特别是在做大型开发时（使用应用开发框架等等）。

在没有自定义异常的情况下，从有返回值的函数中返回错误信息一定非常的棘手，更别提多不优雅了。不好的解决方案包括了传第一个引用类型来接纳错误信息，或总是返回一个对象列表，其中包含着可能的错误对象。以上方式基本上是比较简陋的异常处理方式。适时可做自定义异常处理。

在复杂的环境中，你可以考虑抛出对象而不仅仅是字符串（默认的抛出值）。

if(name === undefined) { throw { name: 'System Error', message: 'A name should always be specified!' } }
标准特性

总是优先考虑使用标准特性。为了最大限度地保证扩展性与兼容性，总是首选标准的特性，而不是非标准的特性（例如：首选string.charAt(3)而不是string[3]；首选 DOM 的操作方法来获得元素引用，而不是某一应用特定的快捷方法）。
简易的原型继承

如果你想在 JavaScript 中继承你的对象，请遵循一个简易的模式来创建此继承。如果你预计你会遇上复杂对象的继承，那可以考虑采用一个继承库，比如 Proto.js by Axel Rauschmayer.

简易继承请用以下方式：

(function(log){ 'use strict'; // Constructor function function Apple(name) { this.name = name; } // Defining a method of apple Apple.prototype.eat = function { log('Eating ' + this.name); }; // Constructor function function GrannySmithApple { // Invoking parent constructor Apple.prototype.constructor.call(this, 'Granny Smith'); } // Set parent prototype while creating a copy with Object.create GrannySmithApple.prototype = Object.create(Apple.prototype); // Set constructor to the sub type, otherwise points to Apple GrannySmithApple.prototype.constructor = GrannySmithApple; // Calling a super method GrannySmithApple.prototype.eat = function { // Be sure to apply it onto our current object with call(this) Apple.prototype.eat.call(this); log('Poor Grany Smith'); }; // Instantiation var apple = new Apple('Test Apple'); var grannyApple = new GrannySmithApple; log(apple.name); // Test Apple log(grannyApple.name); // Granny Smith // Instance checks log(apple instanceof Apple); // true log(apple instanceof GrannySmithApple); // false log(grannyApple instanceof Apple); // true log(grannyApple instanceof GrannySmithApple); // true // Calling method that calls super method grannyApple.eat; // Eating Granny Smith\nPoor Grany Smith }(window.console.log));
使用闭包

闭包的创建也许是 JS 最有用也是最易被忽略的能力了。关于闭包如何工作的合理解释。

切勿在循环中创建函数

在简单的循环语句中加入函数是非常容易形成闭包而带来隐患的。下面的例子就是一个典型的陷阱：

不推荐

(function(log, w){ 'use strict'; // numbers and i is defined in the current function closure var numbers = [1, 2, 3], i; for(i = 0; i < numbers.length; i++) { w.setTimeout(function { // At the moment when this gets executed the i variable, coming from the outer function scope // is set to 3 and the current program is alerting the message 3 times // 'Index 3 with number undefined // If you understand closures in javascript you know how to deal with those cases // It's best to just avoid functions / new closures in loops as this prevents those issues w.alert('Index ' + i + ' with number ' + numbers[i]); }, 0); } }(window.console.log, window));
接下来的改进虽然已经解决了上述例子中的问题或 bug，但还是违反了不在循环中创建函数或闭包的原则。

不推荐

(function(log, w){ 'use strict'; // numbers and i is defined in the current function closure var numbers = [1, 2, 3], i; for(i = 0; i < numbers.length; i++) { // Creating a new closure scope with an IIFE solves the problem // The delayed function will use index and number which are // in their own closure scope (one closure per loop iteration). // --- // Still this is not recommended as we violate our rule to not // create functions within loops and we are creating two! (function(index, number){ w.setTimeout(function { // Will output as expected 0 > 1, 1 > 2, 2 > 3 w.alert('Index ' + index + ' with number ' + number); }, 0); }(i, numbers[i])); } }(window.console.log, window));
接下来的改进已解决问题，而且也遵循了规范。可是，你会发现看上去似乎过于复杂繁冗了，应该会有更好的解决方案吧。

不完全推荐

(function(log, w){ 'use strict'; // numbers and i is defined in the current function closure var numbers = [1, 2, 3], i; // Create a function outside of the loop that will accept arguments to create a // function closure scope. This function will return a function that executes in this // closure parent scope. function alertIndexWithNumber(index, number) { return function { w.alert('Index ' + index + ' with number ' + number); }; } // First parameter is a function call that returns a function. // --- // This solves our problem and we don't create a function inside our loop for(i = 0; i < numbers.length; i++) { w.setTimeout(alertIndexWithNumber(i, numbers[i]), 0); } }(window.console.log, window));
将循环语句转换为函数执行的方式问题能得到立马解决，每一次循环都会对应地创建一次闭包。函数式的风格更加值得推荐，而且看上去也更加地自然和可预料。

推荐

(function(log, w){ 'use strict'; // numbers and i is defined in the current function closure var numbers = [1, 2, 3], i; numbers.forEach(function(number, index) { w.setTimeout(function { w.alert('Index ' + index + ' with number ' + number); }, 0); }); }(window.console.log, window));
eval 函数（魔鬼）

eval不但混淆语境还很危险，总会有比这更好、更清晰、更安全的另一种方案来写你的代码，因此尽量不要使用 evil 函数。
this 关键字

只在对象构造器、方法和在设定的闭包中使用this关键字。this 的语义在此有些误导。它时而指向全局对象（大多数时），时而指向调用者的定义域（在 eval 中），时而指向 DOM 树中的某一节点（当用事件处理绑定到 HTML 属性上时），时而指向一个新创建的对象（在构造器中），还时而指向其它的一些对象（如果函数被call和apply执行和调用时）。
正因为它是如此容易地被搞错，请限制它的使用场景：

在构造函数中
在对象的方法中（包括由此创建出的闭包内）
首选函数式风格

函数式编程让你可以简化代码并缩减维护成本，因为它容易复用，又适当地解耦和更少的依赖。

接下来的例子中，在一组数字求和的同一问题上，比较了两种解决方案。第一个例子是经典的程序处理，而第二个例子则是采用了函数式编程和 ECMA Script 5.1 的数组方法。

例外：往往在重代码性能轻代码维护的情况之下，要选择最优性能的解决方案而非维护性高的方案（比如用简单的循环语句代替 forEach）。

不推荐

(function(log){ 'use strict'; var arr = [10, 3, 7, 9, 100, 20], sum = 0, i; for(i = 0; i < arr.length; i++) { sum += arr[i]; } log('The sum of array ' + arr + ' is: ' + sum) }(window.console.log));推荐
(function(log){ 'use strict'; var arr = [10, 3, 7, 9, 100, 20]; var sum = arr.reduce(function(prevValue, currentValue) { return prevValue + currentValue; }, 0); log('The sum of array ' + arr + ' is: ' + sum); }(window.console.log));
另一个例子通过某一规则对一个数组进行过滤匹配来创建一个新的数组。

不推荐

(function(log){ 'use strict'; var numbers = [11, 3, 7, 9, 100, 20, 14, 10], numbersGreaterTen = , i; for(i = 0; i < numbers.length; i++) { if(numbers[i] > 10) { numbersGreaterTen.push(numbers[i]); } } log('From the list of numbers ' + numbers + ' only ' + numbersGreaterTen + ' are greater than ten'); }(window.console.log));推荐
(function(log){ 'use strict'; var numbers = [11, 3, 7, 9, 100, 20, 14, 10]; var numbersGreaterTen = numbers.filter(function(element) { return element > 10; }); log('From the list of numbers ' + numbers + ' only ' + numbersGreaterTen + ' are greater than ten'); }(window.console.log));
使用 ECMA Script 5

建议使用 ECMA Script 5 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。

数组和对象的属性迭代

用 ECMA5 的迭代方法来迭代数组。使用Array.forEach或者如果你要在特殊场合下中断迭代，那就用Array.every。 (function(log){ 'use strict'; // Iterate over an array and break at a certain condition [1, 2, 3, 4, 5].every(function(element, index, arr) { log(element + ' at index ' + index + ' in array ' + arr); if(index !== 5) { return true; } }); // Defining a simple javascript object var obj = { a: 'A', b: 'B', 'c-d-e': 'CDE' }; // Iterating over the object keys Object.keys(obj).forEach(function(element, index, arr) { log('Key ' + element + ' has value ' + obj[element]); }); }(window.console.log));
不要使用 switch

switch 在所有的编程语言中都是个非常错误的难以控制的语句，建议用 if else 来替换它。

数组和对象字面量

用数组和对象字面量来代替数组和对象构造器。数组构造器很容易让人在它的参数上犯错。

不推荐

// Length is 3. var a1 = new Array(x1, x2, x3); // Length is 2. var a2 = new Array(x1, x2); // If x1 is a number and it is a natural number the length will be x1. // If x1 is a number but not a natural number this will throw an exception. // Otherwise the array will have one element with x1 as its value. var a3 = new Array(x1); // Length is 0. var a4 = new Array;
正因如此，如果将代码传参从两个变为一个，那数组很有可能发生意料不到的长度变化。为避免此类怪异状况，请总是采用更多可读的数组字面量。

推荐

var a = [x1, x2, x3]; var a2 = [x1, x2]; var a3 = [x1]; var a4 = ;
对象构造器不会有类似的问题，但是为了可读性和统一性，我们应该使用对象字面量。

不推荐

var o = new Object; var o2 = new Object; o2.a = 0; o2.b = 1; o2.c = 2; o2['strange key'] = 3;
应该写成这样：

推荐

var o = {}; var o2 = { a: 0, b: 1, c: 2, 'strange key': 3 };
修改内建对象的原型链

修改内建的诸如Object.prototype和Array.prototype是被严厉禁止的。修改其它的内建对象比如Function.prototype，虽危害没那么大，但始终还是会导致在开发过程中难以 debug 的问题，应当也要避免。
自定义 toString 方法

你可以通过自定义toString来控制对象字符串化。这很好，但你必须保证你的方法总是成功并不会有其它副作用。如果你的方法达不到这样的标准，那将会引发严重的问题。如果toString调用了一个方法，这个方法做了一个断言[3]，当断言失败，它可能会输出它所在对象的名称，当然对象也需要调用toString一般在语法和语义上真正需要时才谨慎地使用圆括号。不要用在一元操作符上，例如deletetypeof和void，或在关键字之后，例如,,,new等。
字符串

统一使用单引号(‘)，不使用双引号(“)。这在创建 HTML 字符串非常有好处：

var msg = 'This is some HTML ';
三元条件判断（if 的快捷方法）

用三元操作符分配或返回语句。在比较简单的情况下使用，避免在复杂的情况下使用。没人愿意用 10 行三元操作符把自己的脑子绕晕。

不推荐

if(x === 10) { return 'valid'; } else { return 'invalid'; }推荐
return x === 10 ? 'valid' : 'invalid';
[1]：采用严格规范的语句写法，从根本上杜绝由分号缺失而引起的代码歧义。

[2]：中缀符，指的是像x + y。
[3]：断言一般指程序员在测试测序时的假设，一般是一些布尔表达式，当返回是 true 时，断言为真，代码运行会继续进行；如果条件判断为 false，代码运行停止，你的应用被终止。

**转载请标注原文地址：[https://lion1ou.github.io/Lion/20161110-01](https://lion1ou.github.io/Lion/20161110-01)**
(end)
